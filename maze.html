<html>
<head><style>
body{background-color:#000;}
div{color:#fff;}
</style></head>
<body></body>
<script src="mazeMaker.js"></script>
<script src="makeModule.js"></script>
<script src="structureHelpers.js"></script>
<script>
(function(w, h, body){
	Array.prototype.first = function(test){
		var res, found = false;
		for(var i=0;i<this.length;i++){
			if(test(res = this[i])){
				found = true;
				break;
			}
		}
		if(found){
			return res;
		}
		return null;
	};
	var boxSize, maxY, maxX;
	var setBoxSize = function(s){
		console.log("setting box size",s);
		boxSize = s;
		maxY = Math.floor(h / boxSize);
		maxX = Math.floor(w / boxSize);
	};

	

	var chooseRandom = function(arr){
		return arr[Math.floor(Math.random() * arr.length)];
	};

	var copySet = structureHelpers.copySet;

	var screenPosition = function(x,y){
		return {
			x:x,
			y:y,
			minus:function(p){
				return screenPosition(x - p.x, y - p.y);
			}
		};
	};
	var mazePositionToScreenPosition = function(p){
		return screenPosition(boxSize * (p.x + 1/2), boxSize * (p.y + 1/2));
	};
	
	var direction = mazeMaker.direction;

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx, boxSize, drawPaths){
			if(drawPaths){
				var baseHue = Math.floor(Math.random() * 40);
				m.paths.map(function(p, i){
					ctx.fillStyle = 'hsl('+(baseHue + p[0].depth * 3)+',60%,'+Math.floor(10 + 70 / (1 + p[0].depth / 2))+'%)';
					p.map(function(pp){
						ctx.fillRect(pp.x * boxSize, pp.y * boxSize, boxSize, boxSize);
					});
				});
			}
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				ctx.strokeStyle = '#000';
				ctx.beginPath();
				ctx.moveTo(x1 * boxSize, y1 * boxSize);
				ctx.lineTo(x2 * boxSize, y2 * boxSize);
				ctx.stroke();
			});
		};
		return {draw:draw};
	})();

	var svgMazeDrawer = (function(){
		var draw = function(m, boxSize, drawPaths){
			var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
			svg.setAttribute('width',boxSize * m.maxX);
			svg.setAttribute('height',boxSize * m.maxY);
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				var l = document.createElementNS('http://www.w3.org/2000/svg','line');
				l.setAttribute('x1',x1*boxSize);
				l.setAttribute('y1',y1*boxSize);
				l.setAttribute('x2',x2*boxSize);
				l.setAttribute('y2',y2*boxSize);
				l.setAttribute('stroke','#999');
				svg.appendChild(l);
			});
			return svg;
		};
		return {draw:draw}
	})();

	var mazeWalker = function(m, startPosition){
		var currentPosition = startPosition;
		var currentDirection = chooseRandom(currentPosition.freeDirections);
		var leftOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.TOP;
				case direction.TOP:return direction.LEFT;
				case direction.LEFT: return direction.BOTTOM;
				case direction.BOTTOM:return direction.RIGHT;
			}
		};
		var goInDirection = function(d){
			var next = currentPosition.neighborInDirection(d);
			currentPosition = next;
			return currentPosition;
		};
		var rightOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.BOTTOM;
				case direction.BOTTOM:return direction.LEFT;
				case direction.LEFT: return direction.TOP;
				case direction.TOP:return direction.RIGHT;
			}
		};

		var doStep = function(){
			var toTheLeft = leftOf(currentDirection);
			if(currentPosition.freeDirections.indexOf(toTheLeft) != -1){
				currentDirection = toTheLeft;
			}
			while(currentPosition.freeDirections.indexOf(currentDirection) == -1){
				currentDirection = rightOf(currentDirection);
			}
			return goInDirection(currentDirection);
		};
		return {doStep:doStep};
	};

	var controllableMazeWalker = function(m, startPosition){
		var currentDirection, currentPosition = startPosition, going = false;
		var goInDirection = function(d){
			if(currentPosition.freeDirections.indexOf(d) != -1){
				currentPosition = currentPosition.neighborInDirection(d);
			}
			return currentPosition;
		};
		body.addEventListener('keyup',function(){
			going = false;
		});
		body.addEventListener('keydown',function(e){
			if(e.key === "ArrowUp"){
				currentDirection = direction.TOP;
			}else if(e.key === "ArrowDown"){
				currentDirection = direction.BOTTOM;
			}else if(e.key === "ArrowLeft"){
				currentDirection = direction.LEFT;
			}else if(e.key === "ArrowRight"){
				currentDirection = direction.RIGHT;
			}
			going = true;
		});
		var doStep = function(){
			if(!going){
				return currentPosition;
			}else{
				return goInDirection(currentDirection);
			}
		};
		return {
			doStep:doStep
		};
	};

	var easer = makeModule(function(setPosition, easiness, maxSpeed, _getNextGoal){
		var capAbs = function(x, cap){
			var abs = Math.min(Math.abs(x), cap);
			if(x < 0){
				return -abs;
			}
			return abs;
		};
		var goal, dx, dy, currentX = 0, currentY = 0, getNextGoal = _getNextGoal, interval;
		var update = function(){
			dx = goal.x - currentX;
			dy = goal.y - currentY;
			currentX += capAbs(dx / easiness, maxSpeed)
			currentY += capAbs(dy / easiness, maxSpeed)
			setPosition(screenPosition(currentX, currentY));
			if(Math.abs(dx) + Math.abs(dy) < boxSize / 3){
				goal = getNextGoal();
			}
		};
		var start = function(){
			goal = getNextGoal();
			currentX = goal.x;
			currentY = goal.y;
			interval = setInterval(update, 20);
		};
		var stop = function(){
			clearInterval(interval);
		};
		this.expose({
			start:start,
			stop:stop
		});
		this.extend('bufferEaser',function(){
			var goalBuffer = (function(){
				var q = [];
				var addGoal = function(){
					var newGoal = _getNextGoal();
					if(q.length < 2){
						q.push(newGoal);
					}else{
						var lastDirection = q[q.length - 1].minus(q[q.length - 2]);
						var newDirection = newGoal.minus(q[q.length - 1]);
						if(lastDirection.x * newDirection.x + lastDirection.y * newDirection.y > 0){
							q[q.length - 1] = newGoal;
						}else{
							q.push(newGoal);
						}
					}
				};
				var getNext = function(){
					while(q.length < 10){
						addGoal();
					}
					var n = q[0];
					q.splice(0,1);
					return n;
				};
				return {
					getNext:getNext
				};
			})();
			getNextGoal = goalBuffer.getNext;
		});
		
	});

	var progressMaker = function(setup, done){
		done = done || function(){};
		setup = setup();
		return {
			update:function(x){
				setup.update(x);
			},
			done:function(){setup.teardown();done();}
		};
	};

	var textProgressMaker = function(text){
		return progressMaker(function(){
			var a = document.createElement('div');
			body.appendChild(a);
			return {
				update: function(x){a.innerHTML = text + x.toString();},
				teardown:function(){body.removeChild(a)}
			};
		});
	};

	var createProgress = function(t){
		return textProgressMaker(t+": ");
	};

	

	var walkerThing = makeModule(function(m, setPosition, firstPosition, easiness, maxSpeed){
		var walker, makeWalker, makeEaser, _easer;

		var getNextGoal = function(){
			var p = walker.doStep();
			return mazePositionToScreenPosition(p);
		};
		var start = function(){
			walker = makeWalker(m, firstPosition);
			_easer = makeEaser(setPosition, easiness, maxSpeed, getNextGoal);
			_easer.start();
		};
		var stop = function(){
			_easer.stop();
		};
		this.expose({
			stop:stop,
			start:start
		});
		this.extend('autonomousWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return mazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer.bufferEaser(setPosition, easiness, maxSpeed, getNextGoal);
			};
		});
		this.extend('controllableWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return controllableMazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer(setPosition, easiness, maxSpeed, getNextGoal);
			};
		});
	});

	var positionableThing = (function(){
		var all = [], copies = copySet([], function(o){
			return {
				setPosition:o.setPosition
			};
		});
		var areClose = function(p1,p2){
			return p1 && p2 && Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) < boxSize/2;
		};
		var check = function(){
			for(var i=0;i<all.length;i++){
				for(var j = i+1;j<all.length;j++){
					if(areClose(all[i].getPosition(), all[j].getPosition())){
						all[i].onMeeting(copies.copyOf(all[j]));
						all[j].onMeeting(copies.copyOf(all[i]));
					}else{
						all[i].onCeasingToMeet(copies.copyOf(all[j]));
						all[j].onCeasingToMeet(copies.copyOf(all[i]));
					}
				}
			}
		};
		var makeNew = function(_setPosition, _onMeeting){
			_onMeeting = _onMeeting || function(){};
			var alreadyMeeting = [];
			var onMeeting = function(other){
				if(alreadyMeeting.indexOf(other) == -1){
					_onMeeting(other);
					alreadyMeeting.push(other);
				}
			};
			var onCeasingToMeet = function(other){
				var index;
				if((index = alreadyMeeting.indexOf(other)) != -1){
					alreadyMeeting.splice(index,1);
				}
			};
			var currentPosition;
			var setPosition = function(p){
				currentPosition = p;
				_setPosition(p);
				check();
			};
			return {
				setPosition:setPosition,
				getPosition:function(){return currentPosition;},
				onMeeting:onMeeting,
				onCeasingToMeet:onCeasingToMeet
			};
		};
		return function(_setPosition, onMeeting){
			var n = makeNew(_setPosition, onMeeting);
			all.push(n);
			return copies.addFor(n);
		};
	})();
	
	var levelProvider = (function(){
		var currentCounter, currentBoxSize;
		var reset = function(){
			currentCounter = 1;
			currentBoxSize = 70;
		};
		reset();
		var getNext = function(){
			var l = {
				boxSize:currentBoxSize,
				number:currentCounter
			};
			if(currentBoxSize > 5){
				currentBoxSize -= 5;
			}
			currentCounter++;
			return l;
		};
		return {
			getNext:getNext,
			reset:reset
		};
	})();

	var playLevel = function(l, onSucceed, onFail){
		setBoxSize(l.boxSize);
		mazeMaker.make(maxX, maxY, createProgress, function(model){
			var succeed, fail, svg = svgMazeDrawer.draw(model, boxSize);
			var circleThing = function(color, onMeeting){
				var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
				circle.setAttribute('r',boxSize * 0.2);
				circle.setAttribute('fill',color);
				var setPosition = function(p){
					circle.setAttribute('cx',p.x);
					circle.setAttribute('cy',p.y);
				};
				svg.appendChild(circle);
				return positionableThing(setPosition, onMeeting);
			};
			var initialYellowPosition = {x:0,y:0};
			var yellowCircle = circleThing('#ff0');
			yellowCircle.setPosition(mazePositionToScreenPosition(initialYellowPosition));

			var redCircle = circleThing('#f00',function(c){
				if(c == yellowCircle){
					succeed();
				}
			});
			var initialRedPosition = chooseRandom(model.positions.filter(function(p){
				return p.distanceFrom(initialYellowPosition) > 5;
			}));

			var initialGreenPosition = chooseRandom(model.positions.filter(function(p){
				return 	p.distanceFrom(initialYellowPosition) > 5 &&
						p.distanceFrom(initialRedPosition) > 5;
			}));
			var greenCircle = circleThing('#0f0', function(c){
				if(c == yellowCircle){
					fail();
				}
			});
		
			
			var walkers = [
				walkerThing.controllableWalkerThing(model, redCircle.setPosition, initialRedPosition, 2, 10),
				walkerThing.autonomousWalkerThing(model, greenCircle.setPosition,initialGreenPosition, 2,2)
				];

			var teardown = function(){
				walkers.map(function(w){
					w.stop();
				});
				body.removeChild(svg);
			};

			succeed = function(){
				teardown();
				onSucceed();
			};

			fail = function(){
				teardown();
				onFail();
			};
			
			walkers.map(function(w){
				
				w.start();
			});
			
			
			body.appendChild(svg);
			
		});
	};

	var playAgain = function(){
		playLevel(levelProvider.getNext(),function(){
			if(confirm("You win! Go again?")){
				playAgain();
			}
		},function(){
			if(confirm("You lose! Go again?")){
				levelProvider.reset();
				playAgain();
			}
		});
	};

	playAgain();
	

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>