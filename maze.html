<html>
<head><style>
body{background-color:#000;}
div{color:#fff;}
</style></head>
<body></body><script>
(function(w, h, body){
	Array.prototype.first = function(test){
		var res, found = false;
		for(var i=0;i<this.length;i++){
			if(test(res = this[i])){
				found = true;
				break;
			}
		}
		if(found){
			return res;
		}
		return null;
	};
	var maze, boxSize = 12;
	var maxY = Math.floor(h / boxSize), maxX = Math.floor(w / boxSize);

	var chooseRandom = function(arr, p){
		if(!p){
			return arr[Math.floor(Math.random() * arr.length)];
		}
		arr = arr.map(function(v){return {
			v:v,
			p:p(v)
		};});
		var currentI = 0, currentP = arr[0].p, total = arr.map(function(a){return a.p;}).reduce(function(a,b){return a+b;}), thres = Math.random() * total;
		while(currentP < thres){
			currentP += arr[++currentI].p;
		}
		return arr[currentI].v;
	};

	var timeoutWhile = function(cond, toDo, batchSize, done, update){
		var step = function(){
			setTimeout(function(){
				var count = 0;
				if(cond()){
					do{
						toDo(update);
						count++;
					}while(cond() && count < batchSize);
					step();
				}else{
					done();
				}
			}, 1);
		};
		step();
	};

	
	var direction = {TOP:0,LEFT:1,RIGHT:2,BOTTOM:3};

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx, boxSize, drawPaths){
			if(drawPaths){
				var baseHue = Math.floor(Math.random() * 40);
				m.paths.map(function(p, i){
					ctx.fillStyle = 'hsl('+(baseHue + p[0].depth * 3)+',60%,'+Math.floor(10 + 70 / (1 + p[0].depth / 2))+'%)';
					p.map(function(pp){
						ctx.fillRect(pp.x * boxSize, pp.y * boxSize, boxSize, boxSize);
					});
				});
			}
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				ctx.strokeStyle = '#000';
				ctx.beginPath();
				ctx.moveTo(x1 * boxSize, y1 * boxSize);
				ctx.lineTo(x2 * boxSize, y2 * boxSize);
				ctx.stroke();
			});
		};
		return {draw:draw};
	})();

	var svgMazeDrawer = (function(){
		var draw = function(m, boxSize, drawPaths){
			var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
			svg.setAttribute('width',boxSize * m.maxX);
			svg.setAttribute('height',boxSize * m.maxY);
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				var l = document.createElementNS('http://www.w3.org/2000/svg','line');
				l.setAttribute('x1',x1*boxSize);
				l.setAttribute('y1',y1*boxSize);
				l.setAttribute('x2',x2*boxSize);
				l.setAttribute('y2',y2*boxSize);
				l.setAttribute('stroke','#999');
				svg.appendChild(l);
			});
			return svg;
		};
		return {draw:draw}
	})();

	var mazeWalker = function(m, goToPosition){
		var currentPosition = chooseRandom(m.positions);
		var currentDirection = chooseRandom(currentPosition.freeDirections);
		var leftOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.TOP;
				case direction.TOP:return direction.LEFT;
				case direction.LEFT: return direction.BOTTOM;
				case direction.BOTTOM:return direction.RIGHT;
			}
		};
		var goInDirection = function(d){
			var next;
			if(d == direction.RIGHT){
				next = currentPosition.neighbors.first(function(n){return n.x == currentPosition.x + 1;});
			}else if(d == direction.BOTTOM){
				next = currentPosition.neighbors.first(function(n){return n.y == currentPosition.y + 1;});
			}else if(d == direction.LEFT){
				next = currentPosition.neighbors.first(function(n){return n.x == currentPosition.x - 1;});
			}else if(d == direction.TOP){
				next = currentPosition.neighbors.first(function(n){return n.y == currentPosition.y - 1;});
			}
			goToPosition(next);
			currentPosition = next;
		};
		var rightOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.BOTTOM;
				case direction.BOTTOM:return direction.LEFT;
				case direction.LEFT: return direction.TOP;
				case direction.TOP:return direction.RIGHT;
			}
		};

		var doStep = function(){
			var toTheLeft = leftOf(currentDirection);
			if(currentPosition.freeDirections.indexOf(toTheLeft) != -1){
				currentDirection = toTheLeft;
			}
			while(currentPosition.freeDirections.indexOf(currentDirection) == -1){
				currentDirection = rightOf(currentDirection);
			}
			goInDirection(currentDirection);
		};
		return {doStep:doStep};
	};

	var getPositionsWithNeighbors = function(maxX, maxY, update, done){
		var position = function(x,y){
			return {
				x:x,
				y:y,
				neighbors: [],
				freeDirections: []
			};
		};
		var positionArray = Array.apply(null, new Array(maxX)).map(function(){
			return Array.apply(null, new Array(maxY));
		});
		var currentPosition, size = maxX * maxY, result = [];
		var connectPositions = function(p1, p2){
			p1.neighbors.push(p2);
			p2.neighbors.push(p1);
		};
		var goToPosition = function(p){
			if(currentPosition){
				connectPositions(currentPosition, p);
			}
			result.push(p);
			positionArray[p.x][p.y] = p;
			currentPosition = p;
		};
		var moveInDirection = function(d){
			var newPosition;
			if(d == direction.LEFT){
				newPosition = position(currentPosition.x - 1, currentPosition.y);
				if(currentPosition.y > 0){
					connectPositions(newPosition, positionArray[newPosition.x][newPosition.y - 1]);
				}

			}else if(d == direction.RIGHT){
				newPosition = position(currentPosition.x + 1, currentPosition.y);
				if(currentPosition.y > 0){
					connectPositions(newPosition, positionArray[newPosition.x][newPosition.y - 1]);
				}
			}else if(d == direction.BOTTOM){
				newPosition = position(currentPosition.x, currentPosition.y + 1);
				
			}
			goToPosition(newPosition);
		};
		goToPosition(position(0,0));
		timeoutWhile(function(){return result.length < size}, function(update){
			if(currentPosition.y % 2 == 0){
				if(currentPosition.x == maxX - 1){
					moveInDirection(direction.BOTTOM);
				}else{
					moveInDirection(direction.RIGHT);
				}
			}else{
				if(currentPosition.x == 0){
					moveInDirection(direction.BOTTOM);
				}else{
					moveInDirection(direction.LEFT);
				}
			}
			update(Math.floor(100 * result.length / size)+"%")
		}, 30, function(){
			done(result);
		}, update)
	};
	
	var makeMaze = function(maxX, maxY, createProgress, done){
		var paths, x, y, allBorderParts = [],positions;
		var borderPart = function(x,y,direction,length){
			length = length || 1;
			return {
				x:x,
				y:y,
				direction:direction,
				length: length
			};
		};
		var isExtensionOf = function(borderPart1, borderPart2){
			if(borderPart1.x != borderPart2.x && borderPart1.y != borderPart2.y){
				return false;
			}
			if(borderPart1.x == borderPart2.x){
				return (borderPart1.direction == direction.RIGHT && borderPart2.direction == direction.RIGHT && borderPart2.y == borderPart1.y + borderPart1.length) ||
						(borderPart1.direction == direction.LEFT && borderPart2.direction == direction.LEFT && borderPart2.y == borderPart1.y - borderPart1.length);
			}
			if(borderPart1.y == borderPart2.y){
				return (borderPart1.direction == direction.TOP && borderPart2.direction == direction.TOP && borderPart2.x == borderPart1.x + borderPart1.length) ||
						(borderPart1.direction == direction.BOTTOM && borderPart2.direction == direction.BOTTOM && borderPart2.x == borderPart1.x - borderPart1.length);
			}
		};
		var removeBorderPart = function(test){
			var partToRemove = allBorderParts.first(test);
			if(partToRemove){
				allBorderParts.splice(allBorderParts.indexOf(partToRemove),1);
			}
		};

		var mergeBorderParts = (function(){
			var findMemberForGroup = function(current, candidates, eq){
				var result;
				for(var i=0;i<candidates.length;i++){
					if(
						current.indexOf(candidates[i]) == -1 && 
						(
							current.some(function(c){return eq(c,candidates[i]);}) ||
							current.length == 0
						)
					){
						return candidates[i];
					}
				}
			};
			var mergeGroup = function(g){
				var first = g.first(function(p){return !g.some(function(pp){return p!=pp && isExtensionOf(pp,p);});});
				first.length = g.map(function(p){return p.length;}).reduce(function(a,b){return a+b;});
				g.filter(function(p){return p!=first;}).map(function(p){
					allBorderParts.splice(allBorderParts.indexOf(p),1);
				});
			};
			return function(update, done){
				var left = allBorderParts.slice();
				var leftLengthInitial = left.length;
				var match, currentGroup = [];
				var eq = function(p1,p2){return isExtensionOf(p1,p2) || isExtensionOf(p2,p1);};
				timeoutWhile(function(){return left.length > 0;},function(update){
					match = findMemberForGroup(currentGroup, left, eq);
					if(match){
						left.splice(left.indexOf(match),1);
						currentGroup.push(match);
					}else{
						if(currentGroup.length > 1){
							mergeGroup(currentGroup);
						}
						currentGroup = [];
					}
					update(Math.floor(100 * (1 - left.length / leftLengthInitial))+"%")
				},30,done,update);
			};
		})();

		for(x = 0; x < maxX; x++){
			allBorderParts.push(borderPart(x,0,direction.TOP));
			for(y = 0; y < maxY; y++){
				allBorderParts.push(borderPart(x,y,direction.BOTTOM));
				allBorderParts.push(borderPart(x,y,direction.RIGHT));
			}
		}
		for(y = 0; y < maxY; y++){
			allBorderParts.push(borderPart(0,y,direction.LEFT));
		}
		var connectPositions = function(p1, p2){
			var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
			if(x1 == x2 && Math.abs(y1 - y2) == 1){
				if(y1 > y2){
					removeBorderPart(function(p){return p.x == x1 && (p.y == y2 && p.direction == direction.BOTTOM || p.y == y1 && p.direction == direction.TOP);});
					p2.freeDirections.push(direction.BOTTOM);
					p1.freeDirections.push(direction.TOP);
				}else{
					removeBorderPart(function(p){return p.x == x1 && (p.y == y1 && p.direction == direction.BOTTOM || p.y == y2 && p.direction == direction.TOP);});
					p2.freeDirections.push(direction.TOP);
					p1.freeDirections.push(direction.BOTTOM);
				}
			}else if(y1 == y2 && Math.abs(x1 - x2) == 1){
				if(x1 > x2){
					removeBorderPart(function(p){return p.y == y1 && (p.x == x2 && p.direction == direction.RIGHT || p.x == x1 && p.direction == direction.LEFT);});
					p2.freeDirections.push(direction.RIGHT);
					p1.freeDirections.push(direction.LEFT);
				}else{
					removeBorderPart(function(p){return p.y == y1 && (p.x == x1 && p.direction == direction.RIGHT || p.x == x2 && p.direction == direction.LEFT);});
					p2.freeDirections.push(direction.LEFT);
					p1.freeDirections.push(direction.RIGHT);
				}
			}
		};
		var pathMaker = (function(){

			var make = function(update, done){
				var reachedEnd, nextPosition, currentPosition, visited = [], unvisitedNeighbors, unvisitedPositions = positions.slice(), currentPath = [], paths = [], currentDepth = 0;
				var visitPosition = function(p){
					unvisitedPositions.splice(unvisitedPositions.indexOf(p), 1);
					visited.push(p);
					currentPath.push(p);
					p.depth = currentDepth;
					p.visited = true;
				};
				var getUnvisitedNeighborsOf = function(p){
					return p.neighbors.filter(function(pp){return !pp.visited;})
				};
				var newPath = function(){
					paths.push(currentPath);
					currentPath = [];
				};
				currentPosition = chooseRandom(positions);
				visitPosition(currentPosition);
				var size = positions.length;
				timeoutWhile(function(){return unvisitedPositions.length > 0},function(update){
					reachedEnd = false;
					while((unvisitedNeighbors = getUnvisitedNeighborsOf(currentPosition)).length == 0){
						reachedEnd = true;
						visited.pop();
						currentPosition = visited[visited.length - 1];
					}
					if(reachedEnd){
						currentDepth = currentPosition.depth + 1;
						newPath();
					}
					nextPosition = chooseRandom(unvisitedNeighbors, function(p){
						var desiredDirection = visited.length >= 2 ? {x: currentPosition.x - visited[visited.length - 2].x, y: currentPosition.y - visited[visited.length - 2].y} : {x:0,y:0};
						return Math.pow(3 + currentPath.length / 10, (p.x - currentPosition.x) * desiredDirection.x + (p.y - currentPosition.y) * desiredDirection.y);
					});
					visitPosition(nextPosition);
					connectPositions(currentPosition, nextPosition);
					currentPosition = nextPosition;
					update(Math.floor(100 * (1 - unvisitedPositions.length / size))+"%");
				}, 30, function(){
					newPath();
					done(paths);
				}, update);
			};

			
			return {
				make:make
			};

		})();

		var progress1 = createProgress("initializing");
		getPositionsWithNeighbors(maxX, maxY, progress1.update, function(pos){
			positions = pos;
			var progress2 = createProgress("making paths");
			pathMaker.make(progress2.update, function(p){
				paths = p;
				var progress3 = createProgress("merging borders");
				mergeBorderParts(progress3.update, function(){
					progress3.done();
					progress2.done();
					progress1.done();
					done();
				});
			});
		});
		return {
			connectPositions:connectPositions,
			toString:toString,
			getModel:function(){
				return {
					maxX:maxX,
					maxY:maxY,
					borderParts:allBorderParts.slice(),
					paths:paths.slice(),
					positions:positions.slice()
				};
			}
		};
	};

	var positionEaser = function(setPosition){
		var goalX = 0, goalY = 0, currentX = 0, currentY = 0;
		setInterval(function(){
			currentX += (goalX - currentX) / 4;
			currentY += (goalY - currentY) / 4;
			setPosition(currentX, currentY);
		},20);
		return {
			setTo:function(x, y){
				goalX = x;
				goalY = y;
			}
		};
	};

	var progressMaker = function(setup, done){
		done = done || function(){};
		setup = setup();
		return {
			update:function(x){
				setup.update(x);
			},
			done:function(){setup.teardown();done();}
		};
	};

	var textProgressMaker = function(text){
		return progressMaker(function(){
			var a = document.createElement('div');
			body.appendChild(a);
			return {
				update: function(x){a.innerHTML = text + x.toString();},
				teardown:function(){body.removeChild(a)}
			};
		});
	};

	var createProgress = function(t){
		return textProgressMaker(t+": ");
	};

	var makeWalkerCircle = function(m, color, interval){
		var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
		circle.setAttribute('cx',0);
		circle.setAttribute('cy',0);
		circle.setAttribute('r',Math.max(boxSize / 2 - 3, 5));
		circle.setAttribute('fill',color);
		var easer = positionEaser(function(x,y){
			circle.setAttribute('cx',x);
			circle.setAttribute('cy',y);
		});
		var walker = mazeWalker(m, function(p){
			easer.setTo(boxSize * (p.x + 1/2), boxSize * (p.y + 1/2));
		});
		return {
			node:circle,
			doStep: walker.doStep,
			interval:interval
		};
	};

	var atTheEnd = function(){
		var model = maze.getModel();
		var svg = svgMazeDrawer.draw(model, boxSize);
		var walkers = [makeWalkerCircle(model, '#f00', 75), makeWalkerCircle(model, '#0f0', 125)];
		walkers.map(function(w){
			svg.appendChild(w.node);
			setInterval(w.doStep, w.interval);
		});
		
		
		body.appendChild(svg);
		
	};

	maze = makeMaze(maxX, maxY, createProgress, atTheEnd);

	
	

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>