<html><body></body><script>
(function(w, h, body){
	var maze, boxSize = 5;
	var maxY = Math.floor(h / boxSize), maxX = Math.floor(maxY * w / h);

	var chooseRandom = function(arr, p){
		if(!p){
			return arr[Math.floor(Math.random() * arr.length)];
		}
		arr = arr.map(function(v){return {
			v:v,
			p:p(v)
		};});
		var currentI = 0, currentP = arr[0].p, total = arr.map(function(a){return a.p;}).reduce(function(a,b){return a+b;}), thres = Math.random() * total;
		while(currentP < thres){
			currentP += arr[++currentI].p;
		}
		return arr[currentI].v;
	};

	var timeoutWhile = function(cond, toDo, batchSize, done, update){
		var step = function(){
			setTimeout(function(){
				var count = 0;
				if(cond()){
					do{
						toDo(update);
						count++;
					}while(cond() && count < batchSize);
					step();
				}else{
					done();
				}
			}, 1);
		};
		step();
	};

	var timeoutForEach = function(arr, toDo, batchSize, done, update){
		var i = 0;
		timeoutWhile(function(){return i<arr.length;},function(){
			toDo(arr[i++]);
			update(Math.floor(100 * i / arr.length) + "%");
		}, batchSize, done);
	};

	var direction = {TOP:0,LEFT:1,RIGHT:2,BOTTOM:3};

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx, boxSize, drawPaths){
			if(drawPaths){
				m.paths.map(function(p, i){
					ctx.fillStyle = 'hsl('+(i*20)+',40%,80%)';
					p.map(function(pp){
						ctx.fillRect(pp.x * boxSize, pp.y * boxSize, boxSize, boxSize);
					});
				});
			}
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + 1; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y; y2 = p.y + 1; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + 1; x1 = x2 = p.x + 1;
				}
				ctx.strokeStyle = '#000';
				ctx.beginPath();
				ctx.moveTo(x1 * boxSize, y1 * boxSize);
				ctx.lineTo(x2 * boxSize, y2 * boxSize);
				ctx.stroke();
			});
		};
		return {draw:draw};
	})();
	
	var makeMaze = function(maxX, maxY, update, done){
		var paths, x, y, allBorderParts = [];
		var borderPart = function(x,y,direction,length){
			length = length || 1;
			return {
				x:x,
				y:y,
				direction:direction,
				length: length
			};
		};
		var isExtensionOf = function(borderPart1, borderPart2){
			if(borderPart1.x != borderPart2.x && borderPart1.y != borderPart2.y){
				return false;
			}
			if(borderPart1.x == borderPart2.x){
				return (borderPart1.direction == direction.RIGHT && borderPart2.direction == direction.RIGHT && borderPart2.y == borderPart1.y + borderPart1.length) ||
						(borderPart1.direction == direction.LEFT && borderPart2.direction == direction.LEFT && borderPart2.y == borderPart1.y - borderPart1.length);
			}
			if(borderPart1.y == borderPart2.y){
				return (borderPart1.direction == direction.TOP && borderPart2.direction == direction.TOP && borderPart2.x == borderPart1.x + borderPart1.length) ||
						(borderPart1.direction == direction.BOTTOM && borderPart2.direction == direction.BOTTOM && borderPart2.y == borderPart1.x - borderPart1.length);
			}
		};
		var removeBorderParts = function(test){
			var partsToRemove = allBorderParts.filter(test);
			while(partsToRemove.length > 0){
				allBorderParts.splice(allBorderParts.indexOf(partsToRemove[0]),1);
				partsToRemove.splice(0,1);
			}
		};
		for(x = 0; x < maxX; x++){
			allBorderParts.push(borderPart(x,0,direction.TOP));
			for(y = 0; y < maxY; y++){
				allBorderParts.push(borderPart(x,y,direction.BOTTOM));
				allBorderParts.push(borderPart(x,y,direction.RIGHT));
			}
		}
		for(y = 0; y < maxY; y++){
			allBorderParts.push(borderPart(0,y,direction.LEFT));
		}
		var connectPositions = function(x1, y1, x2, y2){
			if(x1 == x2 && Math.abs(y1 - y2) == 1){
				if(y1 > y2){
					removeBorderParts(function(p){return p.x == x1 && (p.y == y1 && p.direction == direction.TOP || p.y == y2 && p.direction == direction.BOTTOM);});
				}else{
					removeBorderParts(function(p){return p.x == x1 && (p.y == y2 && p.direction == direction.TOP || p.y == y1 && p.direction == direction.BOTTOM);});
				}
			}else if(y1 == y2 && Math.abs(x1 - x2) == 1){
				if(x1 > x2){
					removeBorderParts(function(p){return p.y == y1 && (p.x == x1 && p.direction == direction.LEFT || p.x == x2 && p.direction == direction.RIGHT);});
				}else{
					removeBorderParts(function(p){return p.y == y1 && (p.x == x2 && p.direction == direction.LEFT || p.x == x1 && p.direction == direction.RIGHT);});
				}
			}
		};
		var pathMaker = (function(){
			var position = function(x,y){
				return {
					x:x,
					y:y
				};
			};

			var positions = Array.apply(null, new Array(maxX)).map(function(o, x){
				return Array.apply(null, new Array(maxY)).map(function(o, y){
					return position(x,y);
				});
			}).reduce(function(a,b){return a.concat(b);});

			var getNeighborsOf = function(p){
				return positions.filter(function(pp){return pp.x == p.x && Math.abs(pp.y - p.y) == 1 || pp.y == p.y && Math.abs(pp.x - p.x) == 1;});
			};
			
			var make = function(update, done){
				var reachedEnd, nextPosition, currentPosition, visited = [], unvisitedNeighbors, unvisitedPositions = positions.slice(), currentPath = [], paths = [];
				var visitPosition = function(p){
					unvisitedPositions.splice(unvisitedPositions.indexOf(p), 1);
					visited.push(p);
					currentPath.push(p);
				};
				var getUnvisitedNeighborsOf = function(p){
					return p.neighbors.filter(function(pp){return unvisitedPositions.indexOf(pp) != -1;})
				};
				var newPath = function(){
					paths.push(currentPath);
					currentPath = [];
				};
				currentPosition = chooseRandom(positions);
				visitPosition(currentPosition);
				var size = positions.length;
				timeoutWhile(function(){return unvisitedPositions.length > 0},function(update){
					reachedEnd = false;
					while((unvisitedNeighbors = getUnvisitedNeighborsOf(currentPosition)).length == 0){
						reachedEnd = true;
						currentPosition = visited.pop();
					}
					if(reachedEnd){
						newPath();
					}
					nextPosition = chooseRandom(unvisitedNeighbors, function(p){
						var desiredDirection = visited.length >= 2 ? {x: currentPosition.x - visited[visited.length - 2].x, y: currentPosition.y - visited[visited.length - 2].y} : {x:0,y:0};
						return Math.pow(3 + currentPath.length / 10, (p.x - currentPosition.x) * desiredDirection.x + (p.y - currentPosition.y) * desiredDirection.y);
					});
					visitPosition(nextPosition);
					connectPositions(currentPosition.x, currentPosition.y, nextPosition.x, nextPosition.y);
					currentPosition = nextPosition;
					update(Math.floor(100 * (1 - unvisitedPositions.length / size))+"%");
				}, 30, function(){
					newPath();
					done(paths);
				}, update);
			};

			timeoutForEach(positions, function(p){
				p.neighbors = getNeighborsOf(p);
			}, 30, done, update);
			return {make:make};

		})();

		
		return {
			connectPositions:connectPositions,
			toString:toString,
			getModel:function(){
				return {
					maxX:maxX,
					maxY:maxY,
					borderParts:allBorderParts.slice(),
					paths:paths.slice()
				};
			},
			makePaths:function(update, done){
				pathMaker.make(update, function(p){
					paths = p;
					done();
				});
			}
		};
	};

	

	var progressMaker = function(setup, done){
		done = done || function(){};
		setup = setup();
		return {
			update:function(x){
				setup.update(x);
			},
			done:function(){setup.teardown();done();}
		};
	};

	var progress1 = progressMaker(function(){
		var a = document.createElement('a');
		body.appendChild(a);
		return {
			update: function(x){a.innerHTML = "initializing: " + x.toString();},
			teardown:function(){body.removeChild(a)}
		};
	});

	var progress2 = progressMaker(function(){
		var a = document.createElement('a');
		body.appendChild(a);
		return {
			update: function(x){a.innerHTML = "making paths: " + x.toString();},
			teardown:function(){body.removeChild(a)}
		};
	}, progress1.done);

	maze = makeMaze(maxX, maxY, progress1.update, function(){
		maze.makePaths(progress2.update, function(){
			progress2.done();
			var canvas = document.createElement('canvas');
			canvas.setAttribute('height', boxSize*maxY);
			canvas.setAttribute('width', boxSize*maxX);
			body.appendChild(canvas);
			mazeDrawer.draw(maze.getModel(), canvas.getContext('2d'), boxSize, false);
		});
	});
	
	

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>