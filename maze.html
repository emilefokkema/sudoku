<html>
<head><style>
body{background-color:#000;}
div{color:#fff;}
</style></head>
<body></body>
<script src="mazeMaker.js"></script>
<script src="makeModule.js"></script>
<script src="structureHelpers.js"></script>
<script>
(function(w, h, body){
	Array.prototype.first = function(test){
		var res, found = false;
		for(var i=0;i<this.length;i++){
			if(test(res = this[i])){
				found = true;
				break;
			}
		}
		if(found){
			return res;
		}
		return null;
	};
	var maze, boxSize = 80;
	var maxY = Math.floor(h / boxSize), maxX = Math.floor(w / boxSize);

	var chooseRandom = function(arr, p){
		return arr[Math.floor(Math.random() * arr.length)];
	};

	var copySet = structureHelpers.copySet;

	var screenPosition = function(x,y){
		return {
			x:x,
			y:y,
			minus:function(p){
				return screenPosition(x - p.x, y - p.y);
			}
		};
	};

	
	var direction = mazeMaker.direction;

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx, boxSize, drawPaths){
			if(drawPaths){
				var baseHue = Math.floor(Math.random() * 40);
				m.paths.map(function(p, i){
					ctx.fillStyle = 'hsl('+(baseHue + p[0].depth * 3)+',60%,'+Math.floor(10 + 70 / (1 + p[0].depth / 2))+'%)';
					p.map(function(pp){
						ctx.fillRect(pp.x * boxSize, pp.y * boxSize, boxSize, boxSize);
					});
				});
			}
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				ctx.strokeStyle = '#000';
				ctx.beginPath();
				ctx.moveTo(x1 * boxSize, y1 * boxSize);
				ctx.lineTo(x2 * boxSize, y2 * boxSize);
				ctx.stroke();
			});
		};
		return {draw:draw};
	})();

	var svgMazeDrawer = (function(){
		var draw = function(m, boxSize, drawPaths){
			var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
			svg.setAttribute('width',boxSize * m.maxX);
			svg.setAttribute('height',boxSize * m.maxY);
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				var l = document.createElementNS('http://www.w3.org/2000/svg','line');
				l.setAttribute('x1',x1*boxSize);
				l.setAttribute('y1',y1*boxSize);
				l.setAttribute('x2',x2*boxSize);
				l.setAttribute('y2',y2*boxSize);
				l.setAttribute('stroke','#999');
				svg.appendChild(l);
			});
			return svg;
		};
		return {draw:draw}
	})();

	var mazeWalker = function(m, startPosition){
		var currentPosition = startPosition;
		var currentDirection = chooseRandom(currentPosition.freeDirections);
		var leftOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.TOP;
				case direction.TOP:return direction.LEFT;
				case direction.LEFT: return direction.BOTTOM;
				case direction.BOTTOM:return direction.RIGHT;
			}
		};
		var goInDirection = function(d){
			var next = currentPosition.neighborInDirection(d);
			currentPosition = next;
			return currentPosition;
		};
		var rightOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.BOTTOM;
				case direction.BOTTOM:return direction.LEFT;
				case direction.LEFT: return direction.TOP;
				case direction.TOP:return direction.RIGHT;
			}
		};

		var doStep = function(){
			var toTheLeft = leftOf(currentDirection);
			if(currentPosition.freeDirections.indexOf(toTheLeft) != -1){
				currentDirection = toTheLeft;
			}
			while(currentPosition.freeDirections.indexOf(currentDirection) == -1){
				currentDirection = rightOf(currentDirection);
			}
			return goInDirection(currentDirection);
		};
		return {doStep:doStep};
	};

	var controllableMazeWalker = function(m, startPosition){
		var currentDirection, currentPosition = startPosition, going = false;
		var goInDirection = function(d){
			if(currentPosition.freeDirections.indexOf(d) != -1){
				currentPosition = currentPosition.neighborInDirection(d);
			}
			return currentPosition;
		};
		body.addEventListener('keyup',function(){
			going = false;
		});
		body.addEventListener('keydown',function(e){
			if(e.key === "ArrowUp"){
				currentDirection = direction.TOP;
			}else if(e.key === "ArrowDown"){
				currentDirection = direction.BOTTOM;
			}else if(e.key === "ArrowLeft"){
				currentDirection = direction.LEFT;
			}else if(e.key === "ArrowRight"){
				currentDirection = direction.RIGHT;
			}
			going = true;
		});
		var doStep = function(){
			if(!going){
				return currentPosition;
			}else{
				return goInDirection(currentDirection);
			}
		};
		return {
			doStep:doStep
		};
	};

	var easer = makeModule(function(setPosition, easiness, maxSpeed, _getNextGoal){
		var capAbs = function(x, cap){
			var abs = Math.min(Math.abs(x), cap);
			if(x < 0){
				return -abs;
			}
			return abs;
		};
		var goal, dx, dy, currentX = 0, currentY = 0, getNextGoal = _getNextGoal;
		var update = function(){
			dx = goal.x - currentX;
			dy = goal.y - currentY;
			currentX += capAbs(dx / easiness, maxSpeed)
			currentY += capAbs(dy / easiness, maxSpeed)
			setPosition(screenPosition(currentX, currentY));
			if(Math.abs(dx) + Math.abs(dy) < boxSize / 3){
				goal = getNextGoal();
			}
		};
		var start = function(){
			goal = getNextGoal();
			currentX = goal.x;
			currentY = goal.y;
			setInterval(update, 20);
		};
		this.expose({
			start:start
		});
		this.extend('bufferEaser',function(){
			var goalBuffer = (function(){
				var q = [];
				var addGoal = function(){
					var newGoal = _getNextGoal();
					if(q.length < 2){
						q.push(newGoal);
					}else{
						var lastDirection = q[q.length - 1].minus(q[q.length - 2]);
						var newDirection = newGoal.minus(q[q.length - 1]);
						if(lastDirection.x * newDirection.x + lastDirection.y * newDirection.y > 0){
							q[q.length - 1] = newGoal;
						}else{
							q.push(newGoal);
						}
					}
				};
				var getNext = function(){
					while(q.length < 10){
						addGoal();
					}
					var n = q[0];
					q.splice(0,1);
					return n;
				};
				return {
					getNext:getNext
				};
			})();
			getNextGoal = goalBuffer.getNext;
		});
		
	});

	var progressMaker = function(setup, done){
		done = done || function(){};
		setup = setup();
		return {
			update:function(x){
				setup.update(x);
			},
			done:function(){setup.teardown();done();}
		};
	};

	var textProgressMaker = function(text){
		return progressMaker(function(){
			var a = document.createElement('div');
			body.appendChild(a);
			return {
				update: function(x){a.innerHTML = text + x.toString();},
				teardown:function(){body.removeChild(a)}
			};
		});
	};

	var createProgress = function(t){
		return textProgressMaker(t+": ");
	};

	var mazePositionToScreenPosition = function(p){
		return screenPosition(boxSize * (p.x + 1/2), boxSize * (p.y + 1/2));
	};

	var walkerThing = makeModule(function(m, setPosition, firstPosition, easiness, maxSpeed){
		var walker, makeWalker, makeEaser;
		//var firstPosition = chooseRandom(m.positions);
		
		
		setPosition(firstPosition);
		
		var getNextGoal = function(){
			var p = walker.doStep();
			return mazePositionToScreenPosition(p);
		};
		var start = function(){
			walker = makeWalker(m, firstPosition);
			makeEaser(setPosition, easiness, maxSpeed, getNextGoal).start();
		};
		this.expose({
			//node:circle,
			start:start
		});
		this.extend('autonomousWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return mazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer.bufferEaser(setPosition, easiness, maxSpeed, getNextGoal);
			};
		});
		this.extend('controllableWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return controllableMazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer(setPosition, easiness, maxSpeed, getNextGoal);
			};
		});
	});

	var positionableThing = (function(){
		var all = [], copies = copySet([], function(o){
			return {
				setPosition:o.setPosition,
				node:o.node
			};
		});
		var areClose = function(p1,p2){
			return p1 && p2 && Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) < 30;
		};
		var check = function(){
			for(var i=0;i<all.length;i++){
				for(var j = i+1;j<all.length;j++){
					if(areClose(all[i].getPosition(), all[j].getPosition())){
						all[i].onMeeting(copies.copyOf(all[j]));
						all[j].onMeeting(copies.copyOf(all[i]));
					}
				}
			}
		};
		var makeNew = function(node, _setPosition, onMeeting){
			onMeeting = onMeeting || function(){};
			var currentPosition;
			var setPosition = function(p){
				currentPosition = p;
				_setPosition(p);
				check();
			};
			return {
				setPosition:setPosition,
				node:node,
				getPosition:function(){return currentPosition;},
				onMeeting:onMeeting
			};
		};
		return function(node, _setPosition, onMeeting){
			var n = makeNew(node, _setPosition, onMeeting);
			all.push(n);
			return copies.addFor(n);
		};
	})();
	

	var circleThing = function(color, onMeeting){
		var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
		circle.setAttribute('r',boxSize * 0.2);
		circle.setAttribute('fill',color);
		var setPosition = function(p){
			circle.setAttribute('cx',p.x);
			circle.setAttribute('cy',p.y);
		};
		return positionableThing(circle, setPosition, onMeeting);
	};

	var atTheEnd = function(){
		var model = maze.getModel();
		var svg = svgMazeDrawer.draw(model, boxSize);
		
		var circle1 = circleThing('#f00');
		var circle2 = circleThing('#0f0', function(c){
			if(c == circle3){
				console.log("green meets yellow");
			}
		});
		var circle3 = circleThing('#ff0');
		circle3.setPosition(mazePositionToScreenPosition({x:0,y:0}));
		
		var walkers = [
			walkerThing.controllableWalkerThing(model, circle1.setPosition, chooseRandom(model.positions), 2, 10),
			walkerThing.autonomousWalkerThing(model, circle2.setPosition,chooseRandom(model.positions), 2,5)
			];
		svg.appendChild(circle1.node);
		svg.appendChild(circle2.node);
		svg.appendChild(circle3.node);
		walkers.map(function(w){
			
			w.start();
		});
		
		
		body.appendChild(svg);
		
	};

	maze = mazeMaker.make(maxX, maxY, createProgress, atTheEnd);

	
	

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>