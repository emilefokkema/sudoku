<html>
<head><style>
body{background-color:#000;overflow: hidden;}
span{
	float: left;
}

.circle {
	width:30px;
	height: 20px;
	background-repeat: no-repeat;
}
.redcircle {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"10\" r=\"10\" fill=\"#f00\"/></svg>");
}
.yellowcircle {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"10\" r=\"10\" fill=\"#ff0\"/></svg>");
}
.greencircle {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"10\" r=\"10\" fill=\"#0f0\"/></svg>");
}
.popup{
	background-color:#000;
	border: 1pt solid #fff;
	border-radius:3px;
	font-family:sans-serif;
	font-size:20px;
	color:#fff;
}
.popup-container{
	padding:20px;
	left:50%;
	transform:translateX(-50%);
	-webkit-transform:translateX(-50%);
	position: fixed;
	transition-property:top;
	transition-duration:0.3s;
	-webkit-transition-property:top;
	-webkit-transition-duration:0.3s;
	width:50%;
	height: 30%;
}
.popup-button{
	position: absolute;
	bottom:20px;
}
.left{left:20px;}
.right{right:20px;}
</style></head>
<body></body>
<script src="mazeMaker.js"></script>
<script src="makeModule.js"></script>
<script src="makeNode.js"></script>
<script src="structureHelpers.js"></script>
<script>
(function(w, h, body){
	Array.prototype.first = function(test){
		var res, found = false;
		for(var i=0;i<this.length;i++){
			if(test(res = this[i])){
				found = true;
				break;
			}
		}
		if(found){
			return res;
		}
		return null;
	};
	var boxSize, maxY, maxX;
	var setBoxSize = function(s){
		boxSize = s;
		maxY = Math.floor(h / boxSize);
		maxX = Math.floor(w / boxSize);
	};

	

	var chooseRandom = function(arr){
		return arr[Math.floor(Math.random() * arr.length)];
	};

	var copySet = structureHelpers.copySet;

	var screenPosition = function(x,y){
		return {
			x:x,
			y:y,
			minus:function(p){
				return screenPosition(x - p.x, y - p.y);
			}
		};
	};
	var mazePositionToScreenPosition = function(p){
		return screenPosition(boxSize * (p.x + 1/2), boxSize * (p.y + 1/2));
	};
	
	var direction = mazeMaker.direction;

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx, boxSize, drawPaths){
			if(drawPaths){
				var baseHue = Math.floor(Math.random() * 40);
				m.paths.map(function(p, i){
					ctx.fillStyle = 'hsl('+(baseHue + p[0].depth * 3)+',60%,'+Math.floor(10 + 70 / (1 + p[0].depth / 2))+'%)';
					p.map(function(pp){
						ctx.fillRect(pp.x * boxSize, pp.y * boxSize, boxSize, boxSize);
					});
				});
			}
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				ctx.strokeStyle = '#000';
				ctx.beginPath();
				ctx.moveTo(x1 * boxSize, y1 * boxSize);
				ctx.lineTo(x2 * boxSize, y2 * boxSize);
				ctx.stroke();
			});
		};
		return {draw:draw};
	})();

	var svgMazeDrawer = (function(){
		var draw = function(m, boxSize, drawPaths){
			var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
			svg.setAttribute('width',boxSize * m.maxX);
			svg.setAttribute('height',boxSize * m.maxY);
			svg.setAttribute('style','position:fixed;');
			m.borderParts.map(function(p){
				var x1, y1, x2, y2;
				if(p.direction == direction.TOP){
					x1 = p.x; x2 = p.x + p.length; y1 = y2 = p.y;
				}else if(p.direction == direction.BOTTOM){
					x1 = p.x + 1 - p.length; x2 = p.x + 1; y1 = y2 = p.y + 1;
				}else if(p.direction == direction.LEFT){
					y1 = p.y + 1; y2 = p.y + 1 - p.length; x1 = x2 = p.x;
				}else if(p.direction == direction.RIGHT){
					y1 = p.y; y2 = p.y + p.length; x1 = x2 = p.x + 1;
				}
				var l = document.createElementNS('http://www.w3.org/2000/svg','line');
				l.setAttribute('x1',x1*boxSize);
				l.setAttribute('y1',y1*boxSize);
				l.setAttribute('x2',x2*boxSize);
				l.setAttribute('y2',y2*boxSize);
				l.setAttribute('stroke','#999');
				svg.appendChild(l);
			});
			return svg;
		};
		return {draw:draw}
	})();

	var mazeWalker = function(m, startPosition){
		var currentPosition = startPosition;
		var currentDirection = chooseRandom(currentPosition.freeDirections);
		var leftOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.TOP;
				case direction.TOP:return direction.LEFT;
				case direction.LEFT: return direction.BOTTOM;
				case direction.BOTTOM:return direction.RIGHT;
			}
		};
		var goInDirection = function(d){
			var next = currentPosition.neighborInDirection(d);
			currentPosition = next;
			return currentPosition;
		};
		var rightOf = function(d){
			switch(d){
				case direction.RIGHT:return direction.BOTTOM;
				case direction.BOTTOM:return direction.LEFT;
				case direction.LEFT: return direction.TOP;
				case direction.TOP:return direction.RIGHT;
			}
		};

		var doStep = function(){
			var toTheLeft = leftOf(currentDirection);
			if(currentPosition.freeDirections.indexOf(toTheLeft) != -1){
				currentDirection = toTheLeft;
			}
			while(currentPosition.freeDirections.indexOf(currentDirection) == -1){
				currentDirection = rightOf(currentDirection);
			}
			return goInDirection(currentDirection);
		};
		return {doStep:doStep};
	};

	var controllableMazeWalker = function(m, startPosition){
		var currentDirection, currentPosition = startPosition, going = false;
		var goInDirection = function(d){
			if(currentPosition.freeDirections.indexOf(d) != -1){
				currentPosition = currentPosition.neighborInDirection(d);
			}
			return currentPosition;
		};
		var keyupListener = function(){
			going = false;
		};
		body.addEventListener('keyup',keyupListener);
		var keyDownListener = function(e){
			if(e.key === "ArrowUp"){
				currentDirection = direction.TOP;
			}else if(e.key === "ArrowDown"){
				currentDirection = direction.BOTTOM;
			}else if(e.key === "ArrowLeft"){
				currentDirection = direction.LEFT;
			}else if(e.key === "ArrowRight"){
				currentDirection = direction.RIGHT;
			}
			going = true;
		};
		body.addEventListener('keydown',keyDownListener);
		var doStep = function(){
			if(!going){
				return currentPosition;
			}else{
				return goInDirection(currentDirection);
			}
		};
		var removeListeners = function(){
			console.log("removing listeners");
			body.removeEventListener('keyup', keyupListener);
			body.removeEventListener('keydown', keyDownListener);
		};
		return {
			doStep:doStep,
			removeListeners:removeListeners
		};
	};

	var easer = makeModule(function(setPosition, easiness, maxSpeed, _getNextGoal){
		var capAbs = function(x, cap){
			var abs = Math.min(Math.abs(x), cap);
			if(x < 0){
				return -abs;
			}
			return abs;
		};
		var goal, dx, dy, currentX = 0, currentY = 0, getNextGoal = _getNextGoal, interval;
		var update = function(){
			dx = goal.x - currentX;
			dy = goal.y - currentY;
			currentX += capAbs(dx / easiness, maxSpeed)
			currentY += capAbs(dy / easiness, maxSpeed)
			setPosition(screenPosition(currentX, currentY));
			if(Math.abs(dx) + Math.abs(dy) < boxSize / 3){
				goal = getNextGoal();
			}
		};
		var start = function(){
			goal = getNextGoal();
			currentX = goal.x;
			currentY = goal.y;
			interval = setInterval(update, 20);
		};
		var stop = function(){
			console.log("stopping easer");
			clearInterval(interval);
		};
		this.expose({
			start:start,
			stop:stop
		});
		this.extend('bufferEaser',function(){
			var goalBuffer = (function(){
				var q = [];
				var addGoal = function(){
					var newGoal = _getNextGoal();
					if(q.length < 2){
						q.push(newGoal);
					}else{
						var lastDirection = q[q.length - 1].minus(q[q.length - 2]);
						var newDirection = newGoal.minus(q[q.length - 1]);
						if(lastDirection.x * newDirection.x + lastDirection.y * newDirection.y > 0){
							q[q.length - 1] = newGoal;
						}else{
							q.push(newGoal);
						}
					}
				};
				var getNext = function(){
					while(q.length < 10){
						addGoal();
					}
					var n = q[0];
					q.splice(0,1);
					return n;
				};
				return {
					getNext:getNext
				};
			})();
			getNextGoal = goalBuffer.getNext;
		});
		
	});

	var progressMaker = function(setup, done){
		done = done || function(){};
		setup = setup();
		return {
			update:function(x){
				setup.update(x);
			},
			done:function(){setup.teardown();done();}
		};
	};

	var textProgressMaker = function(text){
		return progressMaker(function(){
			var a = document.createElement('div');
			body.appendChild(a);
			return {
				update: function(x){a.innerHTML = text + (Math.floor(100 * x)).toString() + "%";},
				teardown:function(){body.removeChild(a)}
			};
		});
	};

	var createProgress = function(t){
		return textProgressMaker(t+": ");
	};

	var showPopup = function(html, confirm, reject){
		var div;
		disappear = function(){
			body.removeChild(div.node);
		};
		div = makeNode("<div id='2' class='popup popup-container' style='top:"+(2*h)+"px'><div>"+html+"</div><div id='1'></div></div>",function(buttonDiv, container){
			var ok, cancel;
			if(confirm){
				ok = makeNode("<input type='button' class='popup popup-button right' value='OK'/>");
				buttonDiv.appendChild(ok);
				ok.onclick = function(){
					disappear();
					confirm();
				};
			}
			if(reject){
				cancel = makeNode("<input type='button' class='popup popup-button left' value='Cancel'/>");
				buttonDiv.appendChild(cancel);
				cancel.onclick = function(){
					disappear();
					reject();
				};
			}
			return {
				node:container,
				focus:function(){
					ok.focus();
				},
				setTop:function(p){
					container.style.top = p;
				}
			};
		});
		body.appendChild(div.node);
		div.focus();
		setTimeout(function(){
			div.setTop((h/4)+"px");
		},1);
		
	};

	var walkerThing = makeModule(function(m, setPosition, firstPosition, easiness, maxSpeed){
		var walker, makeWalker, makeEaser, _easer;

		var getNextGoal = function(){
			var p = walker.doStep();
			return mazePositionToScreenPosition(p);
		};
		var start = function(){
			walker = makeWalker(m, firstPosition);
			_easer = makeEaser(setPosition, easiness, maxSpeed, getNextGoal);
			_easer.start();
		};
		var stop = function(){
			_easer.stop();
		};
		this.expose({
			stop:stop,
			start:start
		});
		this.extend('autonomousWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return mazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer.bufferEaser(setPosition, easiness, maxSpeed, getNextGoal);
			};
		});
		this.extend('controllableWalkerThing',function(){
			makeWalker = function(m, firstPosition){
				return controllableMazeWalker(m, firstPosition);
			};
			makeEaser = function(setPosition, easiness, maxSpeed, getNextGoal){
				return easer(setPosition, easiness, maxSpeed, getNextGoal);
			};
			stop = this.override(stop, function(){
				walker.removeListeners();
				this();
			});
			this.expose({
				stop:stop
			});
		});
	});

	var positionableThing = (function(){
		var all = [], copies = copySet([], function(o){
			var c = {
				setPosition:o.setPosition
			};
			return c;
		});
		var areClose = function(p1,p2){
			return p1 && p2 && Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y) < boxSize/2;
		};
		var check = function(){
			for(var i=0;i<all.length;i++){
				for(var j = i+1;j<all.length;j++){
					if(areClose(all[i].getPosition(), all[j].getPosition())){
						all[i].onMeeting(copies.copyOf(all[j]));
						all[j].onMeeting(copies.copyOf(all[i]));
					}else{
						all[i].onCeasingToMeet(copies.copyOf(all[j]));
						all[j].onCeasingToMeet(copies.copyOf(all[i]));
					}
				}
			}
		};
		var makeNew = function(_setPosition, _onMeeting){
			_onMeeting = _onMeeting || function(){};
			var alreadyMeeting = [];
			var onMeeting = function(other){
				if(alreadyMeeting.indexOf(other) == -1){
					_onMeeting(other);
					alreadyMeeting.push(other);
				}
			};
			var onCeasingToMeet = function(other){
				var index;
				if((index = alreadyMeeting.indexOf(other)) != -1){
					alreadyMeeting.splice(index,1);
				}
			};
			var currentPosition;
			var setPosition = function(p){
				currentPosition = p;
				_setPosition(p);
				check();
			};
			return {
				setPosition:setPosition,
				getPosition:function(){return currentPosition;},
				onMeeting:onMeeting,
				onCeasingToMeet:onCeasingToMeet
			};
		};
		return function(_setPosition, onMeeting){
			var n = makeNew(_setPosition, onMeeting);
			all.push(n);
			var c = copies.addFor(n);
			c.remove = function(){
				console.log("removing positionableThing");
				copies.removeFor(n);
				all.splice(all.indexOf(n),1);
			};
			return c;
		};
	})();
	
	var levelProvider = (function(){
		var currentCounter, currentBoxSize, currentGreenSpeed;
		var reset = function(){
			currentCounter = 1;
			currentBoxSize = 70;
			currentGreenSpeed = 1;
		};
		reset();
		var getNext = function(){
			var l = {
				boxSize:currentBoxSize,
				number:currentCounter,
				greenSpeed:currentGreenSpeed
			};
			if(currentCounter == 1){
				l.message = "<span>Use the arrow keys to move </span><span class='circle redcircle'> </span><span>to</span><span class='circle yellowcircle'> </span><span>before</span><span class='circle greencircle'> </span><span>gets there.</span>";
			}
			if(currentCounter % 3 == 0 && currentBoxSize > 5){
				currentBoxSize -= 5;
			}
			currentCounter++;
			currentGreenSpeed += 1;
			return l;
		};
		return {
			getNext:getNext,
			reset:reset
		};
	})();

	var playLevel = function(l, onSucceed, onFail){
		console.log("beginning to play level "+l.number);
		setBoxSize(l.boxSize);
		mazeMaker.make(maxX, maxY, createProgress, function(model){
			var succeed, fail, svg = svgMazeDrawer.draw(model, boxSize), succeeded = false, failed = false;
			var circleThing = function(color, onMeeting){
				var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
				circle.setAttribute('r',boxSize * 0.2);
				circle.setAttribute('fill',color);
				var setPosition = function(p){
					circle.setAttribute('cx',p.x);
					circle.setAttribute('cy',p.y);
				};
				svg.appendChild(circle);
				return positionableThing(setPosition, onMeeting);
			};
			var initialYellowPosition = {x:0,y:0};
			var yellowCircle = circleThing('#ff0');
			yellowCircle.setPosition(mazePositionToScreenPosition(initialYellowPosition));

			var redCircle = circleThing('#f00',function(c){
				if(c == yellowCircle){
					console.log("succeed level "+l.number);
					succeed();
				}
			});
			var initialRedPosition = chooseRandom(model.positions.filter(function(p){
				return p.distanceFrom(initialYellowPosition) > 3;
			}));
			redCircle.setPosition(mazePositionToScreenPosition(initialRedPosition));

			var initialGreenPosition = chooseRandom(model.positions.filter(function(p){
				return 	p.distanceFrom(initialYellowPosition) > 3 &&
						p.distanceFrom(initialRedPosition) > 3;
			}));
			var greenCircle = circleThing('#0f0', function(c){
				if(c == yellowCircle){
					console.log("fail level "+l.number);
					fail();
				}
			});
			greenCircle.setPosition(mazePositionToScreenPosition(initialGreenPosition));
			var walkers = [
				walkerThing.controllableWalkerThing(model, redCircle.setPosition, initialRedPosition, 2, 10),
				walkerThing.autonomousWalkerThing(model, greenCircle.setPosition,initialGreenPosition, 2,l.greenSpeed)
				];

			var teardown = function(){
				walkers.map(function(w){
					w.stop();
				});
				redCircle.remove();
				greenCircle.remove();
				yellowCircle.remove();
				try{
					console.log("removing svg");
					body.removeChild(svg);
				}catch(e){
					console.log("svg had already been removed");
				}
				
			};

			succeed = function(){
				if(!failed){
					teardown();
					onSucceed();
					succeeded = true;
				}
			};

			fail = function(){
				if(!succeeded){
					teardown();
					onFail();
					failed=true;
				}
			};

			body.appendChild(svg);
			
			var start = function(){
				walkers.map(function(w){
					w.start();
				});
			};
			
			if(l.message){
				showPopup(l.message, start);
			}else{
				start();
			}
			
			
			
		});
	};

	var playAgain = function(){
		var l = levelProvider.getNext();
		playLevel(l,function(){
			showPopup("You win level "+l.number+"! Go again?",function(){
				playAgain();
			},function(){});
		},function(){
			showPopup("You lose! Go again?",function(){
				levelProvider.reset();
				playAgain();
			},function(){});
		});
	};

	playAgain();
	

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>