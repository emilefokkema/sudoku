<html><body style="white-space:pre;font-family:monospace;font-size:5px;font-weight:bold;letter-spacing:0.5em"></body><script>
(function(w, h, body){
	var maxY = 30, maxX = maxY;

	var direction = {TOP:0,LEFT:1,RIGHT:2,BOTTOM:3};

	var mazeStringifier = (function(){
		var stringPicture = function(w,h){
			var rows = Array.apply(null, new Array(h)).map(function(){
				return Array.apply(null, new Array(w)).map(function(){return " ";}).join("");
			});
			var put = function(x,y,str){
				rows[y] = rows[y].substr(0,x) + str + rows[y].substr(x+1);
			};
			var toString = function(){
				return rows.join("\n");
			};
			return {
				put:function(x,y,str){
					put(x,y,str);
					return this;
				},
				toString:toString
			};
		};
		var intersectionCharacters = {
			"0123" : "\u253c",
			"012" : "\u2534",
			"013" : "\u2524",
			"01" : "\u2518",
			"023" : "\u251c",
			"02" : "\u2514",
			"03" : "\u2502",
			"0" : "\u2502",
			"123" :"\u252c",
			"12" : "\u2500",
			"13" :"\u2510",
			"1": "\u2500",
			"23" :"\u250c",
			"2": "\u2500",
			"3" :"\u2502"
		};
		var stringify = function(m){
			var pic = stringPicture(2*m.maxX + 1, 2*m.maxY + 1);
			var borderDirections = Array.apply(null, new Array(m.maxX + 1)).map(function(){
				return Array.apply(null, new Array(m.maxY + 1)).map(function(){return [];});
			});
			m.borderParts.map(function(p){
				var x = 2*p.x + 1,y = 2*p.y + 1,str = p.direction == direction.LEFT || p.direction == direction.RIGHT ? "\u2502" : "\u2500";
				if(p.direction == direction.LEFT){
					x -= 1;
					borderDirections[p.x][p.y + 1].push(direction.TOP);
					borderDirections[p.x][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.RIGHT){
					x += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.TOP);
					borderDirections[p.x + 1][p.y].push(direction.BOTTOM);
				}else if(p.direction == direction.TOP){
					y -= 1;
					borderDirections[p.x + 1][p.y].push(direction.LEFT);
					borderDirections[p.x][p.y].push(direction.RIGHT);
				}else if(p.direction == direction.BOTTOM){
					y += 1;
					borderDirections[p.x + 1][p.y + 1].push(direction.LEFT);
					borderDirections[p.x][p.y + 1].push(direction.RIGHT);
				}
				pic.put(x,y,str);
			});
			borderDirections.map(function(c, x){
				c.map(function(b,y){
					if(b.length > 0){
						pic.put(2*x, 2*y, intersectionCharacters[b.sort(function(a,b){return a-b;}).map(function(a){return a.toString();}).join('')]);
					}
				});
			});

			return pic.toString();
		};
		return {stringify:stringify};
	})();

	var mazeDrawer = (function(){
		var draw = function(m, ctx){}
	})()
	
	var maze = (function(maxX, maxY){
		var x, y, allBorderParts = [];
		var borderPart = function(x,y,direction){
			return {
				x:x,
				y:y,
				direction:direction
			};
		};
		var removeBorderParts = function(test){
			var partsToRemove = allBorderParts.filter(test);
			while(partsToRemove.length > 0){
				allBorderParts.splice(allBorderParts.indexOf(partsToRemove[0]),1);
				partsToRemove.splice(0,1);
			}
		};
		for(x = 0; x < maxX; x++){
			allBorderParts.push(borderPart(x,0,direction.TOP));
			for(y = 0; y < maxY; y++){
				allBorderParts.push(borderPart(x,y,direction.BOTTOM));
				allBorderParts.push(borderPart(x,y,direction.RIGHT));
			}
		}
		for(y = 0; y < maxY; y++){
			allBorderParts.push(borderPart(0,y,direction.LEFT));
		}
		var connectPositions = function(x1, y1, x2, y2){
			if(x1 == x2 && Math.abs(y1 - y2) == 1){
				if(y1 > y2){
					removeBorderParts(function(p){return p.x == x1 && (p.y == y1 && p.direction == direction.TOP || p.y == y2 && p.direction == direction.BOTTOM);});
				}else{
					removeBorderParts(function(p){return p.x == x1 && (p.y == y2 && p.direction == direction.TOP || p.y == y1 && p.direction == direction.BOTTOM);});
				}
			}else if(y1 == y2 && Math.abs(x1 - x2) == 1){
				if(x1 > x2){
					removeBorderParts(function(p){return p.y == y1 && (p.x == x1 && p.direction == direction.LEFT || p.x == x2 && p.direction == direction.RIGHT);});
				}else{
					removeBorderParts(function(p){return p.y == y1 && (p.x == x2 && p.direction == direction.LEFT || p.x == x1 && p.direction == direction.RIGHT);});
				}
			}
		};
		return {
			connectPositions:connectPositions,
			toString:toString,
			getModel:function(){
				return {
					maxX:maxX,
					maxY:maxY,
					borderParts:allBorderParts.slice()
				};
			}
		};
	})(maxX, maxY);

	var chooseRandom = function(arr, p){
		if(!p){
			return arr[Math.floor(Math.random() * arr.length)];
		}
		arr = arr.map(function(v){return {
			v:v,
			p:p(v)
		};});
		var currentI = 0, currentP = arr[0].p, total = arr.map(function(a){return a.p;}).reduce(function(a,b){return a+b;}), thres = Math.random() * total;
		while(currentP < thres){
			currentP += arr[++currentI].p;
		}
		return arr[currentI].v;
	};

	var pathMaker = (function(maze, maxX, maxY){
		var position = function(x,y){
			return {
				x:x,
				y:y
			};
		};
		var positions = Array.apply(null, new Array(maxX)).map(function(o, x){
			return Array.apply(null, new Array(maxY)).map(function(o, y){
				return position(x,y);
			});
		}).reduce(function(a,b){return a.concat(b);});
		var getNeighborsOf = function(p){
			return positions.filter(function(pp){return pp.x == p.x && Math.abs(pp.y - p.y) == 1 || pp.y == p.y && Math.abs(pp.x - p.x) == 1;});
		};
		var make = function(){
			var nextPosition, currentPosition, visited = [], unvisitedNeighbors, unvisitedPositions = positions.slice();
			var visitPosition = function(p){
				unvisitedPositions.splice(unvisitedPositions.indexOf(p), 1);
				visited.push(p);
			};
			var getUnvisitedNeighborsOf = function(p){
				return getNeighborsOf(p).filter(function(pp){return unvisitedPositions.indexOf(pp) != -1;})
			};
			
			currentPosition = chooseRandom(positions);
			visitPosition(currentPosition);

			while(unvisitedPositions.length > 0){
				while((unvisitedNeighbors = getUnvisitedNeighborsOf(currentPosition)).length == 0){
					currentPosition = visited.pop();
				}
				nextPosition = chooseRandom(unvisitedNeighbors);
				visitPosition(nextPosition);
				maze.connectPositions(currentPosition.x, currentPosition.y, nextPosition.x, nextPosition.y);
				currentPosition = nextPosition;
			}
		};
		return {make:make};

	})(maze, maxX, maxY);
	pathMaker.make();
	body.appendChild(document.createTextNode(mazeStringifier.stringify(maze.getModel())));

})(document.body.offsetWidth, document.body.offsetHeight, document.body);
</script></html>