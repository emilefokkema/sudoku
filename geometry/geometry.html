<html>
<head>
<LINK href="geometry.css" rel="stylesheet" type="text/css" />
</head>
<body style="margin:0px;padding:0px">
<script src="../makeModule.js"></script>
<script src="../makeNode.js"></script>
<script src="../structureHelpers.js"></script>
<script src="planeMath.js"></script>
<script src="intersectWithBox.js"></script>
<script src="shapeLogic.js"></script>
<script src="intersectionSet.js"></script>
<script src="canvas.js"></script>
<script>
(function(document, w,h){
	var floatPattern = "-?\\d+(?:\\.\\d+)?(?:e-?\\d+)?";
	Array.prototype.lastMin = function(amount){
		var result, m, min = Infinity;
		for(var i = 0; i<this.length;i++){
			m = amount(this[i]);
			if(m <= min){
				min = m;
				result = this[i];
			}
		}
		return result;
	};
	var throttle = function(f, interval){
		var going = false;
		return function(){
			if(!going){
				var args = arguments;
				going = true;
				setTimeout(function(){
					f.apply(null, args);
					going = false;
				}, interval);
			}
		};
	};
	var sender = structureHelpers.sender;
	
	var copySet = structureHelpers.copySet;
	var distinctArray = function(arr){
		var arr2 = arr.slice();
		var push = function(o){
			if(arr.indexOf(o) == -1){
				arr.push(o);
			}
		};
		arr.splice(0,arr.length);
		arr2.map(function(o){push(o);});
		return {
			arr:arr,
			push:push
		};
	};
	var shapeFilter = {
		ALL: 1,
		POINT: 2,
		NONE:3,
		LINE:4,
		CIRCLE:5,
		LOCUS: 6,
		SEGMENT: 7,
		LINE_ISH: 8,
		NOT_LOCUS: 9
	};
	var obj = {sender:sender,shapeFilter:shapeFilter,copySet:copySet, w:w, h:h, throttle:throttle};
	window.initGeometry(obj);
	var planeMath = obj.planeMath;
	

	var intersectionSet = obj.intersectionSet;

	var canvas = obj.canvas;

	
	var log = (function(){
		
		var allCalls = [];
		var call = function(f, name, args){
			var toString = function(getShapeName){
				return name+'('+args.map(getShapeName).join(',')+')';
			};
			return {
				f:f,
				name:name,
				args:args,
				apply:function(){
					f.apply(null, args);
				},
				toString:toString
			};
		};
		var addCall = function(f, name, args){
			allCalls.push(call(f, name, args));
		};
		var registeredMaker;
		var register = function(maker){
			registeredMaker = maker;
			for(var m in maker){
				if(maker.hasOwnProperty(m)){
					maker[m] = (function(orig, m){
						return function(){
							addCall(orig, m, Array.prototype.slice.apply(arguments));
							orig.apply(maker, arguments);
						};
					})(maker[m], m);
				}
			}
		};
		
		var toString = function(){
			var allShapes = distinctArray([]);
			allCalls.map(function(c){
				c.args.map(function(a){allShapes.push(a);});
			});
			var shapeNames = copySet(allShapes.arr, function(s, i){return i.toString();});
			return allCalls
				.map(function(c){
					return c.toString(shapeNames.copyOf);
				}).join('')+
				';['+
				allShapes.arr.map(function(s){
					return s.toConstructionString(shapeNames.copyOf);
				}).join(';')+";"+
				']';
		};
		var argumentMakers = [
			{
				level:0,
				matches:function(kind){return kind == "point";},
				make:function(info, label, hidden){
					console.log(label);
					return function(){
						var match = info.match(new RegExp("("+floatPattern+"),("+floatPattern+")"));
						var p = planeMath.point(parseFloat(match[1]), parseFloat(match[2]));
						p = canvas.addPoint({location:p});
						if(label){
							p.setLabel(label);
						}
						if(hidden){
							p.hideUnhide();
						}
						return p;
					};
				}
			},{
				level:0,
				matches:function(kind){return kind == "circle";},
				make:function(info, label, hidden){
					return function(){
						var match = info.match(new RegExp("\\(("+floatPattern+"),("+floatPattern+")\\),("+floatPattern+")"));
						var c = canvas.addCircle({center:planeMath.point(parseFloat(match[1]), parseFloat(match[2])),r:parseFloat(match[3])});
						if(label){
							c.setLabel(label);
						}
						if(hidden){
							c.hideUnhide();
						}
						return c;
					};
				}
			},
			{
				level:0,
				matches:function(kind){return kind == "line";},
				make:function(info, label, hidden){
					return function(){
						var match = info.match(new RegExp("\\(("+floatPattern+"),("+floatPattern+")\\),\\(("+floatPattern+"),("+floatPattern+")\\)"));
						var l = canvas.addLine({p1:planeMath.point(parseFloat(match[1]),parseFloat(match[2])),p2:planeMath.point(parseFloat(match[3]),parseFloat(match[4]))});
						if(label){
							l.setLabel(label);
						}
						if(hidden){
							l.hideUnhide();
						}
						return l;
					};
				}
			},
			{
				level:0,
				matches:function(kind){return kind == "segment";},
				make:function(info, label, hidden){
					return function(){
						var match = info.match(new RegExp("\\(("+floatPattern+"),("+floatPattern+")\\),\\(("+floatPattern+"),("+floatPattern+")\\)"));
						var l = canvas.addSegment({p1:planeMath.point(parseFloat(match[1]),parseFloat(match[2])),p2:planeMath.point(parseFloat(match[3]),parseFloat(match[4]))});
						if(label){
							l.setLabel(label);
						}
						if(hidden){
							l.hideUnhide();
						}
						return l;
					};
				}
			},
			{
				level:1,
				matches:function(kind){return kind == "intersection";},
				make:function(info){
					return function(argByIndex){
						var matchWithId, matchWithPoint = info.match(new RegExp("(\\d+),(\\d+),\\(("+floatPattern+"),("+floatPattern+")\\)"));
						if(matchWithPoint){
							return canvas.getIntersectionForShapesAndPoint(argByIndex(matchWithPoint[1]), argByIndex(matchWithPoint[2]), planeMath.point(parseFloat(matchWithPoint[3]), parseFloat(matchWithPoint[4])));
						}
						else{
							matchWithId = info.match(new RegExp("(\\d+),(\\d+),(\\d+)"));
							return canvas.getIntersectionForShapesAndId(argByIndex(matchWithId[1]), argByIndex(matchWithId[2]), parseInt(matchWithId[3]));
						}
					};
				}
			},{
				level:0,
				matches:function(kind){return kind == "locus";},
				make:function(info, label, hidden){
					return function(){
						return canvas.addLocus({});
					};
				}
			}
		];
		
		var backFromString = function(s){
			var match = s.match(/^((?:\w+\([^)]+\))+);\[([^\]]+)\]$/);
			if(match){
				var commands = match[1].match(/\w+\([^)]+\)(?:\.\{[^}]+\})?/g);
				var argsStrings = match[2].match(/.*?;/g);
				var makers = argsStrings.map(function(s){
					var match = s.match(/(\w+)\((.*)\)(?:\.\{([^}]+)\})?(h)?;/);
					var maker = argumentMakers.filter(function(m){return m.matches(match[1])})[0];
					return {level:maker.level,make:maker.make(match[2], match[3], match[4])};
				});
				var argsArr = Array.apply(null, new Array(argsStrings.length));
				var argByIndex = function(i){return argsArr[i];};
				var levels = distinctArray(makers.map(function(m){return m.level;})).arr.sort(function(a,b){return a-b;});
				levels.map(function(l){
					makers.filter(function(m){return m.level == l}).map(function(m){
						argsArr[makers.indexOf(m)] = m.make(argByIndex);
					});
				});
				commands.map(function(c){
					var match = c.match(/(\w+)\(([^)]+)\)/);
					var methodName = match[1];
					var args = match[2].match(/\d+/g).map(function(i){return argsArr[parseInt(i)];});
					registeredMaker[methodName].apply(null, args);
				});
			}
		};
		var removeCallsWithArgument = function(a){
			allCalls = allCalls.filter(function(c){
				return !c.args.some(function(aa){return aa == a;});
			});
		};
		canvas.newShapeOnRemove(function(getWrapper){
			return function(){
				removeCallsWithArgument(getWrapper());
			};
		});
		return {
			addCall: addCall,
			register:register,
			toString:toString,
			backFromString:backFromString,
			removeCallsWithArgument:removeCallsWithArgument
		};
	})();

	

	var structure = (function(){
		var linkExistence;
		var allLinks = [];
		
		
		var intersectionLinks = [];
		var getLinksForDependentShape = function(s){
			return allLinks.filter(function(l){return l.dependent == s;});
		};
		var isDependentShape = function(s){
			return getLinksForDependentShape(s).length > 0 || getIntersectionLinksForDependentShape(s).length > 0;
		};
		var isMovableShape = function(s){
			return !isDependentShape(s) || (getIntersectionLinksForDependentShape(s).length == 0 && !getLinksForDependentShape(s).some(function(l){return l.freedom == 0;}));
		};
		var getIntersectionLinksForDependentShape = function(s){
			return intersectionLinks.filter(function(l){return l.p == s;});
		};
		var getAllLinkedShapes = function(dependent, soFar){
			soFar = soFar || distinctArray([dependent]);
			getLinksForDependentShape(dependent).map(function(l){
				soFar.push(l.independent);
				getAllLinkedShapes(l.independent, soFar);
			});
			getIntersectionLinksForDependentShape(dependent).map(function(l){
				soFar.push(l.s1);
				soFar.push(l.s2);
				getAllLinkedShapes(l.s1, soFar);
				getAllLinkedShapes(l.s2, soFar);
			});
			return soFar.arr;
		};
		var getAllLinksForShape = function(dependent, soFar){
			soFar = soFar || distinctArray([]);
			getLinksForDependentShape(dependent).map(function(l){
				soFar.push(l);
				getAllLinksForShape(l.independent, soFar);
			});
			getIntersectionLinksForDependentShape(dependent).map(function(l){
				soFar.push(l);
				getAllLinksForShape(l.s1, soFar);
				getAllLinksForShape(l.s2, soFar);
			});
			return soFar.arr;
		};
		
		var changeLink = function(dependent, independent, howToChange, constants, freedom){
			var apply = function(){
				independent.onchange(function(oldSpecs, newSpecs){
					howToChange(oldSpecs, newSpecs, dependent.getChanger(), constants ? constants.map(function(s){return s.getSpecs();}) : [], dependent, independent);
				});
				linkExistence(dependent, [independent]);
			};
			var clone = function(getCopyFor, getIntersectionForShapes){
				return changeLink(getCopyFor(dependent), getCopyFor(independent), howToChange, constants ? constants.map(getCopyFor): [], freedom);
			};
			return {
				dependent: dependent,
				independent: independent,
				howToChange: howToChange,
				constants: constants,
				freedom:freedom,
				apply:apply,
				clone:clone
			};
		};
		var intersectionLink = function(pointShape, s1, s2, i){
			var apply = function(){
				var setLocation = function(){
					var loc = i.calculate();
					if(loc){
						pointShape.makeAvailable(true);
						pointShape.getChanger().setLocation(loc);
					}else{
						pointShape.makeAvailable(false);
					}
				};
				linkExistence(pointShape, [i.s1, i.s2]);
				i.s1.onchange(setLocation);
				i.s2.onchange(setLocation);
				setLocation();
			};
			var clone = function(getCopyFor, getIntersectionForShapes){
				return intersectionLink(
					getCopyFor(pointShape),
					getCopyFor(s1),
					getCopyFor(s2),
					getIntersectionForShapes(
						getCopyFor(s1),
						getCopyFor(s2),
						getCopyFor(pointShape).getSpecs().location
						)
					);
			};
			return {
				s1:s1,
				s2:s2,
				p: pointShape,
				apply: apply,
				clone: clone
			};
		};

		var movePointAround = function(pointShape){
			var independent = getLinksForDependentShape(pointShape)[0].independent;
			return independent.movePointAround(pointShape.getSpecs().location);
		};
		linkExistence = function(s, ss){
			ss.map(function(s_){
				if(s_.onremove){
					s_.onremove(function(){s.remove();});
				}
				s_.onchangeavailability(function(b){s.makeAvailable(b);});
			});
		};
		var linkChange = function(dependent, independent, howToChange, constants, freedom){
			freedom = freedom || 0;
			var link = changeLink(dependent, independent, howToChange, constants, freedom);
			allLinks.push(link);
			link.apply();
		};
		var linkToIntersection = function(dependentPoint, s1, s2, i){
			var link = intersectionLink(dependentPoint, s1, s2, i);
			intersectionLinks.push(link);
			link.apply();
		};
		var maker = {
			point: function(canvasPoint, canvasShape){
				var putOnShapeClosestTo;
				if(!canvasShape){
					canvasPoint.ondrag(function(p){
						canvasPoint.getChanger().setLocation(p);
					});
				}else{
					putOnShapeClosestTo = function(p){
						canvasPoint.getChanger().setLocation(canvasShape.closestPointTo(p));
					};
					canvasPoint.ondrag(putOnShapeClosestTo);
					putOnShapeClosestTo(canvasPoint.getSpecs().location);
					linkChange(canvasPoint, canvasShape, function(oldSpecs, newSpecs, changer, constants, dependent, independent){
						changer.setLocation(independent.repositionPoint(dependent.getSpecs().location, oldSpecs, newSpecs));
					}, null, 1);
				}
				
				return {
					onchange: function(f){canvasPoint.onchange(f);}
				};
			},
			pointOnIntersection: function(canvasPoint, i){
				
				linkToIntersection(canvasPoint, i.s1, i.s2, i);
			},
			circle: function(canvasPointCenter, canvasCircle, canvasPointBoundary){
				if(!canvasPointBoundary){
					linkChange(canvasCircle, canvasPointCenter, function(oldSpecs, newSpecs, changer){
						changer.setCenter(newSpecs.location);
					}, null, 1);
					canvasCircle.ondrag(function(p){
						var center = canvasCircle.getSpecs().center;
						var changer = canvasCircle.getChanger();
						changer.setR(center.minus(p).mod());
					});
				}else{
					
					linkChange(
						canvasCircle,
						canvasPointBoundary,
						function(oldSpecs, newSpecs, changer, constants){
							changer.together(function(){
								this.setCenter(constants[0].location);
								this.setR(newSpecs.location.minus(constants[0].location).mod());
							});
						},
						[canvasPointCenter], 0);
					linkChange(
						canvasCircle,
						canvasPointCenter,
						function(oldSpecs, newSpecs, changer, constants){
							changer.together(function(){
								this.setCenter(newSpecs.location);
								this.setR(newSpecs.location.minus(constants[0].location).mod());
							});
						},
						[canvasPointBoundary], 0);
				}
			},
			line: function(canvasPoint1, canvasLine, canvasPoint2){
				if(!canvasPoint2){
					canvasLine.ondrag(function(p){
						canvasLine.getChanger().moveTo(p);
					});

					linkChange(canvasLine, canvasPoint1, function(oldSpecs, newSpecs, changer){
						var diff = newSpecs.location.minus(oldSpecs.location);
						changer.translateBy(diff);
					}, null, 1);
				}else{
					var changer = canvasLine.getChanger();
					changer.setP1(canvasPoint1.getSpecs().location);
					changer.setP2(canvasPoint2.getSpecs().location);
					
					

					linkChange(canvasLine, canvasPoint2, function(oldSpecs, newSpecs, changer){
						changer.setP2(newSpecs.location);
					}, null, 0);

					linkChange(canvasLine, canvasPoint1, function(oldSpecs, newSpecs, changer){
						changer.setP1(newSpecs.location);
					}, null, 0);
				}
			},
			segment: function(canvasPoint1, s, canvasPoint2){
				linkChange(s, canvasPoint2, function(oldSpecs, newSpecs, changer){
					changer.setP2(newSpecs.location);
				}, null, 0);

				linkChange(s, canvasPoint1, function(oldSpecs, newSpecs, changer){
					changer.setP1(newSpecs.location);
				}, null, 0);
			},
			perpendicularLine: function(canvasPoint, canvasPerpendicularLine, canvasLine){
				linkChange(canvasPerpendicularLine, canvasPoint, function(oldSpecs, newSpecs, changer){
					changer.translateBy(newSpecs.location.minus(oldSpecs.location));
				}, null, 0);

				linkChange(canvasPerpendicularLine, canvasLine, function(oldSpecs, newSpecs, changer){
					changer.setFromP1(newSpecs.p2.minus(newSpecs.p1).matrix(0, -1, 1, 0));
				}, null, 0);
			},
			parallelLine: function(canvasPoint, canvasParallelLine, canvasLine){
				linkChange(canvasParallelLine, canvasPoint, function(oldSpecs, newSpecs, changer){
					changer.translateBy(newSpecs.location.minus(oldSpecs.location));
				}, null, 0);

				linkChange(canvasParallelLine, canvasLine, function(oldSpecs, newSpecs, changer){
					changer.setFromP1(newSpecs.p2.minus(newSpecs.p1));
				}, null, 0);
			},
			perpendicularBisector: function(canvasPoint1, perpBis, canvasPoint2){
				linkChange(perpBis, canvasPoint1, function(oldSpecs, newSpecs, changer, constants){
					changer.together(function(){
						this.setP1(newSpecs.location.plus(constants[0].location).scale(1/2));
						this.setFromP1(constants[0].location.minus(newSpecs.location).matrix(0, -1, 1, 0));
					});
				}, [canvasPoint2], 0);

				linkChange(perpBis, canvasPoint2, function(oldSpecs, newSpecs, changer, constants){
					changer.together(function(){
						this.setP1(constants[0].location.plus(newSpecs.location).scale(1/2));
						this.setFromP1(newSpecs.location.minus(constants[0].location).matrix(0, -1, 1, 0));
					});
				}, [canvasPoint1], 0);
			},
			pointLineReflection: function(canvasPoint, line, canvasPointReflection){
				linkChange(canvasPointReflection, line, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(planeMath.reflectPointInLine(newSpecs.p1, newSpecs.p2, constants[0].location));
				}, [canvasPoint], 0);

				linkChange(canvasPointReflection, canvasPoint, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(planeMath.reflectPointInLine(constants[0].p1, constants[0].p2, newSpecs.location));
				}, [line], 0);
			},
			locus: function(canvasPoint1, locusShape, canvasPoint2){
				var allShapesInvolved = getAllLinkedShapes(canvasPoint1);
				var shapesToWatch = allShapesInvolved.filter(function(s){return isMovableShape(s);});

				if(shapesToWatch.some(function(s){return s == canvasPoint2;}) && isDependentShape(canvasPoint2)){
					console.log("ok");
					var allLinks = getAllLinksForShape(canvasPoint1);
					var intersections = intersectionSet();
					var copies = copySet(allShapesInvolved, function(s){return s.getNewShapeLogic();});
					intersections.makeForShapes(copies.allCopies());
					allLinks.map(function(l){
						l.clone(copies.copyOf, intersections.getForShapes).apply();
					});
					var p1Copy = copies.copyOf(canvasPoint1), p2Copy = copies.copyOf(canvasPoint2);
					var setAllCopies = (function(){
						var result = sender();
						allShapesInvolved.map(function(o){
							var c = copies.copyOf(o);
							result.add(function(){
								c.getChanger().useSpecs(o.getSpecs());
							});
						});
						return result;
					})();
					
					var createPoints = throttle(function(){
						console.log("create points");
						var originalPoints = movePointAround(canvasPoint2), pointSets = [], newPoints = [];
						pointSets.push(newPoints);
						originalPoints.map(function(p){
							p2Copy.getChanger().setLocation(p);
							if(p1Copy.isAvailable()){
								newPoints.push(p1Copy.getSpecs().location);
							}else{
								newPoints = [];
								pointSets.push(newPoints);
							}
						});
						locusShape.getChanger().setPointSets(pointSets);
						
					}, 10);
					canvasPoint1.onchange(function(oldSpecs, newSpecs){
						setAllCopies();
						createPoints();
					});
					canvasPoint1.onremove(function(){
						locusShape.remove();
					});
					locusShape.onremove(function(){createPoints = function(){};});
					createPoints();
				}else{
					console.log("not ok");
				}
			},
			midpoint: function(canvasPoint1, canvasPoint2, canvasPoint3){
				linkChange(canvasPoint2, canvasPoint1, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(newSpecs.location.plus(constants[0].location).scale(0.5));
				}, [canvasPoint3], 0);

				linkChange(canvasPoint2, canvasPoint3, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(newSpecs.location.plus(constants[0].location).scale(0.5));
				}, [canvasPoint1], 0);
			},
			angleBisector: function(canvasPoint1, canvasPoint2, canvasPoint3, line){
				linkChange(line, canvasPoint1, function(oldSpecs, newSpecs, changer, constants){
					changer.together(function(){
						this.setP1(constants[0].location);
						this.setP2(planeMath.getPointOnAngleBisector(newSpecs.location, constants[0].location, constants[1].location));
					});
				}, [canvasPoint2, canvasPoint3], 0);

				linkChange(line, canvasPoint2, function(oldSpecs, newSpecs, changer, constants){
					changer.together(function(){
						this.setP1(newSpecs.location);
						this.setP2(planeMath.getPointOnAngleBisector(constants[0].location, newSpecs.location, constants[1].location));
					});
				}, [canvasPoint1, canvasPoint3], 0);

				linkChange(line, canvasPoint3, function(oldSpecs, newSpecs, changer, constants){
					changer.together(function(){
						this.setP1(constants[1].location);
						this.setP2(planeMath.getPointOnAngleBisector(constants[0].location, constants[1].location, newSpecs.location));
					});
				}, [canvasPoint1, canvasPoint2], 0);
			}
		};
		log.register(maker);
		return maker;
	})();

	var action = (function(){
		var selectLocationOrPoint = function(send, suggest){
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.onmouseovernotshape(function(e){
				suggest(planeMath.point(e.clientX, e.clientY));
			});
			canvas.onmouseovershape(function(s, e){
				suggest(s.closestPointTo(planeMath.point(e.clientX, e.clientY)));
			});
			canvas.onclicknotshape(function(e){
				send(planeMath.point(e.clientX, e.clientY));
			});
			canvas.onclickshape(function(s,e){
				send(s.closestPointTo(planeMath.point(e.clientX, e.clientY)), s);
			});
		};
		var selectLocationOrShapeOrIntersection = function(send, suggest){
			canvas.setMouseFilter(canvas.mouseFilter.NOT_LOCUS);
			canvas.setShapeCursor(canvas.cursor.none);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovernotshape(function(e){
				suggest(planeMath.point(e.clientX, e.clientY));
			});
			canvas.onmouseovershape(function(s,e){
				suggest(s.closestPointTo(planeMath.point(e.clientX, e.clientY)));
			});
			canvas.onmouseoverintersection(function(i, e){
				suggest(i.calculate());
			});
			canvas.onclicknotshape(function(e){
				send(planeMath.point(e.clientX, e.clientY));
			});
			canvas.onclickshape(function(s, e){
				send(s.closestPointTo(planeMath.point(e.clientX, e.clientY)), s);
			});
			canvas.onclickintersection(function(i){
				send(null, null, i);
			});
		};
		var selectPoint = function(send, suggest){
			suggest = suggest || function(){};
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onclickshape(function(s, e){
				send(s);
			});
			canvas.onmouseovernotshape(function(e){
				suggest(planeMath.point(e.clientX, e.clientY));
			});
			canvas.onmouseovershape(function(s, e){
				suggest(s.closestPointTo(planeMath.point(e.clientX, e.clientY)));
			});
		};
		var selectLine = function(send){
			selectShape(send, canvas.mouseFilter.LINE);
		};
		var selectShape = function(send, mouseFilter){
			mouseFilter = mouseFilter || canvas.mouseFilter.ALL;
			canvas.setMouseFilter(mouseFilter);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovershape();
			canvas.onmouseovernotshape();
			canvas.onclickshape(function(s, e){
				send(s);
			});

		};
		return {
			doNothing: function(){
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.setShapeCursor(canvas.cursor.abouttograb);
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.onclickshape();
				canvas.onclicknotshape();
				canvas.onmousedownonshape(action.startMoving);
				canvas.onmouseovershape();
				canvas.onmouseoverintersection();
				canvas.onclickintersection();
				canvas.onmouseovernotshape();
				canvas.onmouseupSingle();
			},
			select: function(stop){
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.onmousedownonshape();
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.setShapeCursor(canvas.cursor.none);
				canvas.onclickshape(function(s, e){
					canvas.selectShape(s);
				});
				canvas.onclicknotshape(function(e){
					canvas.clearSelection();
				});
				return function(){
					canvas.clearSelection();
					stop();
				};
			},
			hideUnhide: function(stop){
				canvas.showHidden();
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.onmousedownonshape();
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.setShapeCursor(canvas.cursor.none);
				canvas.onclicknotshape();
				canvas.onclickshape(function(s, e){
					s.hideUnhide();
				});
				return function(){
					canvas.hideHidden();
					stop();
				};
			},
			startMoving: function(s, e){
				canvas.setShapeCursor(canvas.cursor.grabbing);
				canvas.setNoShapeCursor(canvas.cursor.grabbing);
				var doMove = function(e){
					s.dragTo(planeMath.point(e.clientX, e.clientY));
				};

				canvas.onmouseupSingle(action.doNothing);
				canvas.onmouseovershape(function(s, e){doMove(e);});
				canvas.onmouseovernotshape(doMove);
				canvas.onmouseoverintersection(function(i,e){doMove(e);});
				doMove(e);
			},
			makePointStructure: function(res, stop){
				var p = canvas.addPoint({
					location: planeMath.point(200,200)
				}, true);
				
				selectLocationOrShapeOrIntersection(function(l, s, i){
					if(i){
						res(structure.pointOnIntersection(p, i));
					}else{
						if(s){
							res(structure.point(p, s));
						}else{
							res(structure.point(p));
						}
					}
					p.exclude(false);
					stop();
				},function(l){
					p.getChanger().setLocation(l);
				});
				
				return function(){
					p.remove();
					stop();
				};
			},
			makeCircleStructure: function(res, stop){
				var revert = stop;
				var chosenCenter, growCircle, circle;
				selectPoint(function(s){
					chosenCenter = s;
					circle = canvas.addCircle({center:chosenCenter.getSpecs().location,r:20});
					growCircle = function(p){circle.getChanger().setR(p.minus(chosenCenter.getSpecs().location).mod());};
					selectLocationOrPoint(function(l, p){
						if(p){
							res(structure.circle(chosenCenter, circle, p));
							stop();
						}else{
							res(structure.circle(chosenCenter, circle));
							stop();
						}
					},function(l){
						growCircle(l);
					});
					
					revert = function(){
						circle.remove();
						stop();
					};
				});
				return function(){
					revert();
				};
			},
			makeLineStructure: function(res, stop){
				var revert = stop;
				var chosenP1, moveLine, line;
				selectPoint(function(s){
					chosenP1 = s;
					line = canvas.addLine({p1:chosenP1.getSpecs().location, p2:chosenP1.getSpecs().location.plus(planeMath.point(100,0))});
					moveLine = function(p){line.getChanger().moveTo(p);};
					selectLocationOrPoint(function(l, p){
						if(p){
							res(structure.line(chosenP1, line, p));
							stop();
						}else{
							res(structure.line(chosenP1, line));
							stop();
						}
					},function(l){
						moveLine(l);
					});
					
					revert = function(){
						line.remove();
						stop();
					};
				});
				return function(){
					revert();
				};
			},
			makeSegmentStructure: function(res, stop){
				var revert = stop;
				var moveSegment, segment;
				selectPoint(function(p1){
					segment = canvas.addSegment({p1:p1.getSpecs().location, p2:p1.getSpecs().location.plus(planeMath.point(100,0))});
					moveSegment = function(p){segment.getChanger().setP2(p);};
					selectPoint(function(p2){
						res(structure.segment(p1, segment, p2));
						stop();
					},function(l){
						moveSegment(l);
					});
					revert = function(){
						segment.remove();
						stop();
					};
				});
				return function(){
					revert();
				};
			},
			makePerpendicularLine: function(res, stop){
				var chosenPoint, revert = stop;
				selectPoint(function(s){
					chosenPoint = s;
					selectShape(function(l){
						var lSpecs = l.getSpecs(), p1 = chosenPoint.getSpecs().location, p2 = p1.plus(lSpecs.p2.minus(lSpecs.p1).matrix(0,-1,1,0));
						var perpLine = canvas.addLine({p1:p1, p2:p2});
						res(structure.perpendicularLine(chosenPoint, perpLine, l));
						stop();
					}, canvas.mouseFilter.LINE_ISH);
				});
				return function(){
					revert();
				};
			},
			makeParellelLine: function(res, stop){
				var chosenPoint, revert = stop;
				selectPoint(function(s){
					chosenPoint = s;
					selectShape(function(l){
						var lSpecs = l.getSpecs(), p1 = chosenPoint.getSpecs().location, p2 = p1.plus(lSpecs.p2.minus(lSpecs.p1));
						var perpLine = canvas.addLine({p1:p1, p2:p2});
						res(structure.parallelLine(chosenPoint, perpLine, l));
						stop();
					}, canvas.mouseFilter.LINE_ISH);
				});
				return function(){
					revert();
				};
			},
			makePerpendicularBisector: function(res, stop){
				var p1, revert = stop;
				selectPoint(function(p1){
					selectPoint(function(p2){
						var p1loc = p1.getSpecs().location, p2loc = p2.getSpecs().location, newp1loc = p1loc.plus(p2loc).scale(1/2);
						var perpBis = canvas.addLine({
							p1: newp1loc,
							p2: newp1loc.plus(p2loc.minus(p1loc).matrix(0, -1, 1, 0))
						});
						res(structure.perpendicularBisector(p1, perpBis, p2));
						stop();
					});
				});
				return function(){
					revert();
				};
			},
			makeLocus: function(res, stop){
				
				selectPoint(function(point1){
					selectPoint(function(point2){
						res(structure.locus(point1, canvas.addLocus({}), point2));
						stop();
					});
				});
				return stop;
			},
			makePointLineReflection: function(res, stop){
				selectPoint(function(p){
					selectLine(function(l){
						var lSpecs = l.getSpecs();
						var refl = canvas.addPoint({location: planeMath.reflectPointInLine(lSpecs.p1, lSpecs.p2, p.getSpecs().location)});
						res(structure.pointLineReflection(p, l, refl));
						stop();
					});
				});
				return stop;
			},
			makeMidpoint: function(res, stop){
				selectPoint(function(p1){
					selectPoint(function(p2){
						var p = canvas.addPoint({location:p1.getSpecs().location.plus(p2.getSpecs().location).scale(0.5)});
						res(structure.midpoint(p1, p, p2));
						stop();
					});
				});
				return stop;
			},
			makeAngleBisector: function(res, stop){
				selectPoint(function(p1){
					selectPoint(function(p2){
						selectPoint(function(p3){
							var p1Loc = p1.getSpecs().location, p2loc = p2.getSpecs().location, p3Loc = p3.getSpecs().location;
							var p = getPointOnAngleBisector(p1Loc, p2loc, p3Loc);
							var l = canvas.addLine({p1: p2loc, p2: p});
							res(structure.angleBisector(p1, p2, p3, l));
							stop();
						});
					});
				});
				return stop;
			},
			setLabel:function(res, stop){
				var revert = stop;
				selectShape(function(s){
					var labelloc = s.getLabelLocation();
					makeNode("<input type='text' style='width:30px;position:absolute;left:"+(labelloc.x + 5)+"px;top:"+(labelloc.y - 15)+"px' id='1'>", function(input){
						var remove = function(){
							document.body.removeChild(input);
						};
						document.body.appendChild(input);
						input.focus();
						input.addEventListener('blur',function(){
							s.setLabel(input.value);
							remove();
							res();
							stop();
						});
						
						revert = function(){
							remove();
							stop();
						};
					});
				});
				return function(){
					revert();
				};
			}
		};
	})();

	var hash = (function(){
		var shorten = function(h){
			var rgx = new RegExp("\\(("+floatPattern + ","+floatPattern+")\\)", "g");
			h = h.match(/([^\]]*)(\[[^\]]*\])/);
			var replacer = (function(){
				var seen = [];
				return function(m, p1){
					var index = seen.indexOf(p1);
					if(index == -1){
						seen.push(p1);
						return "("+p1+")";
					}else{
						return "("+index.toString()+")";
					}
				};
			})();
			return h[1]+h[2].replace(rgx, replacer);
		};
		var longen = function(h){
			var rgx = new RegExp("\\(("+floatPattern+","+floatPattern+"|\\d+)\\)","g");
			h = h.match(/([^\]]*)(\[[^\]]*\])/);
			var replacer = (function(){
				var seen = [];
				return function(m, p1){
					if(p1.indexOf(",") != -1){
						var pair = p1.match(new RegExp(floatPattern+","+floatPattern))[0];
						seen.push(pair);
						return "("+pair+")";
					}else{
						return "("+seen[parseInt(p1.match(/\d+/)[0])]+")";
					}
				}
			})();
			return h[1]+h[2].replace(rgx, replacer);
		};
		var read = function(){
			var state, s = window.location.hash.substr(1);
			if(s){
				state = longen(decodeURI(s));
				log.backFromString(state);
				history.push(state);
			}
		};
		var history = (function(){
			var states = [];
			window.states = states;
			var push = function(s){
				if(s != states[states.length-1]){
					states.push(s);
				}
			};
			var nextToLast = function(){
				if(states.length > 1){
					states.splice(states.length - 1, 1);
					return states[states.length - 1];
				}
			};
			return {
				push:push,
				nextToLast:nextToLast
			};
		})();
		var write = function(){
			console.log("writing state");
			var newState = log.toString();
			window.location.hash = encodeURI(shorten(newState));
			history.push(newState);
		};
		var nextToLast = function(){
			var oldState = history.nextToLast();
			if(oldState){
				canvas.clear();
				log.backFromString(oldState);
				window.location.hash = encodeURI(shorten(oldState));
			}
		};
		return {
			write:write,
			nextToLast:nextToLast,
			read:read
		};
	})();

	canvas.onmouseup(function(){console.log("mouseup");hash.write();});
	hash.read();

	var button = (function(){
		var positionProvider = function(){
			var x = 20, y = 20;
			return {
				next:function(){
					var p = {x:x,y:y};
					x += 40;
					if(x>=300){
						x = 20;
						y+=40;
					}
					return p;
				}
			};
		};
		var leftPosition = positionProvider(), rightPosition = positionProvider();
		var addClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class') + " "+name);
		};
		var removeClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class').split(/[\s]+/g).filter(function(c){return c!=name;}).join(' '));
		};
		var button = function(a, className, right){
			var p = (right ? rightPosition : leftPosition).next();
			var b = makeNode("<div id='1' class='button"+(className?" "+className:"")+"' style='"+(right ? "right:"+p.x+"px" : "left:"+p.x+"px")+";top:"+p.y+"px'></div>", function(div){
				var makeActive = function(){addClass(div, 'active');};
				var makeNonActive = function(){removeClass(div, 'active');};
				var normalOnClick = function(e){
					var stop;
					e.preventDefault();
					makeActive();
					stop = a(function(){
						makeNonActive();
						div.onclick = normalOnClick;
					});
					if(stop){
						div.onclick = function(){
							stop();
							makeNonActive();
							div.onclick = normalOnClick;
						};
					}
					
				};
				div.onclick = normalOnClick;
				document.body.appendChild(div);
			});
		};
		return button;
	})();

	button(function(deactivateButton){
		return action.makePointStructure(function(p){
			
		}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "point");

	button(function(deactivateButton){
		return action.makeCircleStructure(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "circle");

	button(function(deactivateButton){
		return action.makeLineStructure(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "line");

	button(function(deactivateButton){
		return action.makeSegmentStructure(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "segment");

	button(function(deactivateButton){
		return action.makePerpendicularLine(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "perpendicular");

	button(function(deactivateButton){
		return action.makeParellelLine(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "parallel");

	button(function(deactivateButton){
		return action.makePerpendicularBisector(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		})
	},"bisect");

	button(function(deactivateButton){
		return action.makePointLineReflection(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "reflect-line");

	button(function(deactivateButton){
		return action.makeMidpoint(function(){}, function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "midpoint");

	button(function(deactivateButton){
		return action.makeLocus(function(){},function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "locus");

	button(function(deactivateButton){
		return action.makeAngleBisector(function(){},function(){
			action.doNothing();
			hash.write();
			deactivateButton();
		});
	}, "angle-bisector");

	button(function(deactivateButton){
		return action.setLabel(function(){}, function(){
			action.doNothing();
			deactivateButton();
			hash.write();
		});
	}, "label");

	button(function(deactivateButton){
		return action.select(function(){
			action.doNothing();
			deactivateButton();
		});
		
	}, "select", true);

	button(function(deactivateButton){
		return action.hideUnhide(function(){
			action.doNothing();
			deactivateButton();
		});
	},"hide", true);

	button(function(deactivateButton){
		canvas.removeSelection();
		deactivateButton();
		hash.write();
	}, "remove", true);

	button(function(deactivateButton){
		makeNode('<div style="position:absolute;left:0px;top:0px;width:100%;height:100%;background-color:#fff" id="1"/>',function(div){
			div.appendChild(canvas.toSvg());
			document.body.innerHTML = '';
			document.body.appendChild(div);
		});
		deactivateButton();
	}, "svg", true);

	button(function(deactivateButton){
		canvas.clear();
		hash.write();
		deactivateButton();
	}, "clear", true);

	button(function(deactivateButton){
		hash.nextToLast();
		deactivateButton();
	}, "undo", true);

	action.doNothing();

	

})(document, document.body.offsetWidth, document.body.offsetHeight);
</script>
</body>
</html>