<html>
<body style="margin:0px;padding:0px">
<script src="makeModule.js"></script>
<script>
(function(document, w,h){
	var throttle = function(f, interval){
		var going = false;
		return function(){
			if(!going){
				var args = arguments;
				going = true;
				setTimeout(function(){
					f.apply(null, args);
					going = false;
				}, interval);
			}
		};
	};
	var sender = function(){
		var todo= [];
		var f = function(){
			var args = arguments;
			todo.map(function(g){
				g.apply(null, args);
			});
		};
		f.add = function(g){todo.push(g);return f;};
		return f;
	};
	var promise = function(evaluator){
		var reason, value, pending = true, resolved = false;
		var then = function(v){};
		var notThen = function(r){};
		var resolve = function(v){
			if(!resolved && pending){
				value = v;
				resolved = true;
				pending = false;
				then(value);
			}
		};
		var reject = function(r){
			if(pending){
				pending = false;
				reason = r;
				notThen(reason);
			}
		};
		evaluator.apply(null, [resolve, reject]);
		return {
			then: function(onResolve, onReject){
				return promise(function(res, rej){
					if(pending){
						then = function(v){
							res(onResolve(v));
						};
						notThen = function(r){
							rej(r);
							onReject(r);
						};
					}else{
						if(resolved){
							res(onResolve(value));
						}else{
							rej(reason);
							onReject(reason);
						}
					}
				});
			},
			getValue:function(){if(!pending && resolved){return value;}}
		};
	};
	var point = function(x,y){
		if(x==undefined || y==undefined){
			console.log("oeps");
		}
		return {
			x:x,
			y:y,
			minus: function(p){return point(x - p.x, y - p.y);},
			plus: function(p){return point(x + p.x, y + p.y);},
			mod: function(){return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));},
			scale: function(r){return point(r*x, r*y);},
			unit: function(){return this.scale(1/this.mod());}
		};
	};
	var canvas = (function(){
		var context, c = document.createElement('canvas');
		c.setAttribute('width', w);
		c.setAttribute('height', h);
		document.body.appendChild(c);
		context = c.getContext('2d');

		var shape = makeModule(function(specs){
			var fill = specs.fill || 'transparent';
			var stroke = specs.stroke || 'black';
			var thickness = specs.thickness || 2;
			var name = specs.name || 'shape';
			var draw = function(ctx){
				ctx.strokeStyle = stroke;
				ctx.lineWidth = thickness;
				ctx.fillStyle = fill;
			};
			var contains = function(p){return distance(p) < 10;};
			var distance = function(p){return Infinity;};
			var closestPointTo = function(p){return point(0,0);}
			var getSpecs = function(){return {};};
			var onmouseover = sender().add(function(e){
				stroke = '#f00';
			});
			var onchange = sender();
			var ondrag = sender();
			var changer = {};
			var getChanger = function(){
				var o = {};
				for(var f in changer){
					if(changer.hasOwnProperty(f)){
						o[f] = function(){
							changer[f].apply(null, arguments);
							onchange(getSpecs());
						};
					}
				}
				return o;
			};
			var onmouseout = sender().add(function(e){
				stroke = 'black';
			});
			var onclick = sender();

			this.expose({
				draw: draw,
				contains: contains,
				onmouseover: onmouseover,
				onmouseout: onmouseout,
				onclick: onclick,
				ondrag: ondrag,
				onchange: onchange,
				setName: function(n){name = n;},
				toString:function(){return '['+name+']';},
				changer:{},
				getSpecs: getSpecs,
				getChanger: getChanger,
				dragTo: function(p){ondrag(p);}
			});
			this.extend('circle', function(_specs){
				var center = _specs.center || point(0,0);
				var r = _specs.r || 1;
				
				draw = this.override(draw, function(ctx){
					this(ctx);
					ctx.beginPath();
					ctx.arc(center.x, center.y, r, 0, 2*Math.PI);
					ctx.stroke();
				});

				distance = function(p){
					return Math.abs(center.minus(p).mod() - r);
				};

				closestPointTo = function(p){
					return center.plus(p.minus(center).unit().scale(r));
				};

				changer = {
					setR: function(r_){r = r_;}
				};

				getSpecs = function(){
					return {
						center:center,
						r:r
					};
				};
				this.expose({
					draw:draw,
					closestPointTo: closestPointTo,
					getSpecs: getSpecs
				});
			});
			this.extend('point',function(_specs){
				var loc = _specs.location || point(0,0);
				
				draw = this.override(draw, function(ctx){
					fill = stroke;
					stroke = 'transparent';
					this(ctx);
					ctx.beginPath();
					ctx.arc(loc.x, loc.y, 2*thickness, 0, 2*Math.PI);
					ctx.fill();
				});

				distance = function(p){
					return loc.minus(p).mod();
				};

				closestPointTo = function(p){return loc;};

				changer = {
					setLocation: function(l){loc = l;}
				};

				getSpecs = function(){
					return {
						location: loc
					};
				};
				this.expose({
					draw:draw,
					closestPointTo: closestPointTo,
					getSpecs: getSpecs
				});
			});
		});

		var shapes = [];

		var draw = throttle(function(){
			c.width = w;
			shapes.map(function(s){
				s.draw(context);
			});
		}, 2);

		var onmouseovershape = function(s, e){};

		var onclickshape = function(s, e){};

		var onmousedownonshape = function(s, e){};

		var onmouseovernotshape = function(e){};

		var onmouseup = function(e){};

		var onclicknotshape = function(e){};

		var addShape = function(s, toBeExcludedFromMouseEvents){
			s.setName('shape'+(shapes.length));
			s.toBeExcludedFromMouseEvents = toBeExcludedFromMouseEvents || false;
			shapes.push(s);
			draw();
			return {
				remove: function(){
					var index = shapes.indexOf(s);
					if(index != -1){
						shapes.splice(index, 1);
						draw();
					}
				},
				onmouseover:function(f){s.onmouseover.add(f);},
				onmouseout: function(f){s.onmouseout.add(f);},
				onclick: function(f){s.onclick.add(f);},
				onchange: function(f){s.onchange.add(f);},
				ondrag: function(f){s.ondrag.add(f);},
				shape:s
			};
		};

		var mouseActionHandler = function(doToHitShape, doToNotHitShape, doIfNotHitShape){
			doToHitShape = doToHitShape || function(){};
			doToNotHitShape = doToNotHitShape || function(){};
			doIfNotHitShape = doIfNotHitShape || function(){};
			return function(e){
				var hitShape = false;
				shapes.map(function(s){
					if(!s.toBeExcludedFromMouseEvents && s.contains(point(e.clientX, e.clientY))){
						hitShape = true;
						doToHitShape(s, e);
					}else{
						doToNotHitShape(s, e);
					}
				});
				if(!hitShape){
					doIfNotHitShape(e);
				}
				draw();
			};
		};

		c.addEventListener('mousemove', mouseActionHandler(
			function(s, e){
				s.onmouseover(e);
				onmouseovershape(s, e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				onmouseovernotshape(e);
			}
			
		));

		c.addEventListener('mousedown', mouseActionHandler(
			function(s, e){
				onmousedownonshape(s, e);
			}
			

			));

		c.addEventListener('mouseup', function(e){
			onmouseup(e);
			draw();
		})

		c.addEventListener('click',mouseActionHandler(
			function(s, e){
				s.onclick(e);
				onclickshape(s, e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				onclicknotshape(e);
			}
			
		));

		



		return {
			addCircle: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.circle({}, specs), toBeExcludedFromMouseEvents);
			},
			addPoint: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.point({}, specs), toBeExcludedFromMouseEvents);
			},
			onmouseovershape: function(f){onmouseovershape = f || function(){};},
			onmousedownonshape: function(f){onmousedownonshape = f || function(){};},
			onmouseovernotshape: function(f){
				onmouseovernotshape = f || function(){};
			},
			onclickshape: function(f){onclickshape = f || function(){};},
			onclicknotshape: function(f){onclicknotshape = f || function(){};},
			haspointer: function(){c.style.cursor = "-webkit-grab";},
			isgrabbing: function(){c.style.cursor = "-webkit-grabbing";},
			onmouseup: function(f){onmouseup = f || function(){};},
			hasnopointer: function(){
				c.style.cursor = "default";
			}
		};

	})(w,h);

	

	




	

	var freePointStructure = function(canvasPoint){
		canvasPoint.ondrag(function(p){
			canvasPoint.shape.getChanger().setLocation(p);
		});
		return {
			onchange: function(f){canvasPoint.onchange(f);}
		};
	};
	
	var c = freePointStructure(canvas.addPoint({
		location: point(200,200)
	}));

	var doNothing = function(){
		canvas.onclickshape();
		canvas.onclicknotshape();
		canvas.onmousedownonshape(startMoving);
		canvas.onmouseovershape(canvas.haspointer);
		canvas.onmouseovernotshape(canvas.hasnopointer);
	};

	var startMoving = function(s, e){
		var doMove = function(e){
			canvas.isgrabbing();
			s.dragTo(point(e.clientX, e.clientY));
		};

		canvas.onmouseup(doNothing);
		canvas.onmouseovershape(function(s, e){doMove(e);});
		canvas.onmouseovernotshape(doMove);
		doMove(e);
	};

	var makePoint = function(res, stop){
		var p = canvas.addPoint({
			location: point(200,200)
		}, true);
		
		canvas.onmouseovershape(function(s, e){
			p.shape.getChanger().setLocation(s.closestPointTo(point(e.clientX, e.clientY)));
		});
		canvas.onmouseovernotshape(function(e){
			p.shape.getChanger().setLocation(point(e.clientX, e.clientY));
		});
		canvas.onclickshape(function(s, e){
			stop();
			p.remove();
			res(p);
		});
		canvas.onclicknotshape(function(e){
			stop();
			p.remove();
			res(p);
		});
	};


	doNothing();
	// makePoint(function(p){
	// 	var p = canvas.addPoint(p.shape.getSpecs());
	// }, doNothing);

	


})(document, document.body.offsetWidth, document.body.offsetHeight);
</script>
</body>
</html>