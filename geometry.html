<html>
<head>
<style>
.button {
	width: 30px;
	height: 30px;
	background-color: #ddd;
	position: absolute;
	border-radius: 3px;
	border: 1px solid #aaa;
}
.button:hover
{
	border: 1px solid #000;
	
}
.point {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"15\" r=\"3\" fill=\"black\" /></svg>");
}
.circle {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"15\" r=\"10\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.line {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"2\" y1=\"28\" x2=\"28\" y2=\"2\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.active {
	border: 1px solid #f00;
	background-color: #daa;
}
.remove {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"4\" y1=\"26\" x2=\"26\" y2=\"4\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/><line x1=\"4\" y1=\"4\" x2=\"26\" y2=\"26\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
</style>
</head>
<body style="margin:0px;padding:0px">
<script src="makeModule.js"></script>
<script src="makeNode.js"></script>
<script>
(function(document, w,h){
	var throttle = function(f, interval){
		var going = false;
		return function(){
			if(!going){
				var args = arguments;
				going = true;
				setTimeout(function(){
					f.apply(null, args);
					going = false;
				}, interval);
			}
		};
	};
	var sender = function(){
		var todo= [];
		var f = function(){
			var args = arguments;
			todo.map(function(g){
				g.apply(null, args);
			});
		};
		f.add = function(g){todo.push(g);return f;};
		return f;
	};
	var point = function(x,y){
		
		return {
			x:x,
			y:y,
			minus: function(p){return point(x - p.x, y - p.y);},
			plus: function(p){return point(x + p.x, y + p.y);},
			cross:function(p){return x*p.y - y*p.x;},
			mod: function(){return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));},
			scale: function(r){return point(r*x, r*y);},
			unit: function(){return this.scale(1/this.mod());},
			toString: function(){return "("+x+","+y+")";},
			equals: function(p){return this == p|| (x == p.x && y == p.y);},
			matrix:function(a,b,c,d){return point(a*x+b*y,c*x+d*y);},
			dot:function(p){return x*p.x + y*p.y;}
		};
	};

	var intersectLines = function(p1,p2,q1,q2){
		var x1 = p2.minus(p1);
		var x2 = q2.minus(q1);
		var cross = x2.cross(x1);
		if(cross == 0){
			return null;
		}
		var st = q1.minus(p1).matrix(-x2.y, x2.x, -x1.y, x1.x).scale(1/cross);
		return p1.plus(p2.minus(p1).scale(st.x));
	};

	var intersectCircles = function(p1, r1, p2, r2, index){
		var sina, cosa, d = p1.minus(p2).mod();
		if(r1 + r2 < d || r1 + d < r2 || r2 + d < r1 || d == 0){
			return null;
		}else if(r1 + r2 == d){
			return p1.plus(p2.minus(p1).unit().scale(r1));
		}else{
			cosa = (r1 * r1 - r2 * r2 + d * d) / (2 * d * r1);
			sina = Math.sqrt(1 - cosa * cosa) * (index == 0 ? 1 : -1);
			return p1.plus(p2.minus(p1).unit().scale(r1).matrix(cosa, -sina, sina, cosa));
		}
	};

	var intersectLineAndCircle = function(p1, p2, c, r, index){
		var sina, cossign, cosa, x = c.minus(p1), y = p2.minus(p1);
		var cross, dot = x.dot(y);
		var closestToCenter = p1.plus(y.unit().scale(dot/y.mod()));
		var d = closestToCenter.minus(c).mod();
		if(d == 0){
			return c.plus(y.unit().scale(r * (index == 0 ? 1 : -1)));
		}else if(d > r){
			return null;
		}else if(d == r){
			return closestToCenter;
		}else{
			cossign = (x.cross(y) > 0 ? 1 : -1)
			cosa = (d / r) * cossign;
			
			sina = Math.sqrt(1 - cosa * cosa) * (index == 0 ? 1 : -1);
			return c.plus(closestToCenter.minus(c).unit().scale(r * cossign).matrix(cosa, -sina, sina, cosa));
		}
	};

	var intersectWithBox = (function(){
		
		var sides = [
			{p1:point(0,0), p2: point(w,0)},
			{p1:point(w,0), p2: point(w,h)},
			{p1:point(w,h), p2: point(0,h)},
			{p1:point(0,h), p2: point(0,0)}
		];
		var intersectWithSide = function(p1, p2, side){
			return intersectLines(p1, p2, side.p1, side.p2);
		};
		

		return function(p1, p2){
			if(p1.x == p2.x){
				return {p1:intersectWithSide(p1, p2, sides[0]), p2: intersectWithSide(p1, p2, sides[2])};
			}
			//if(p1.y == p2.y){
			return {p1:intersectWithSide(p1, p2, sides[1]), p2: intersectWithSide(p1, p2, sides[3])};
			//}
			
		};
	})();

	var canvas = (function(){
		var context, c = document.createElement('canvas');
		c.setAttribute('width', w);
		c.setAttribute('height', h);
		document.body.appendChild(c);
		context = c.getContext('2d');

		var shapeFilter = {
			ALL: 0,
			POINT: 1,
			NONE:2,
			LINE:3,
			CIRCLE:4
		};



		var currentMouseFilter = shapeFilter.ALL;

		var shape = makeModule(function(specs){
			var fill = specs.fill || 'transparent';
			var stroke = specs.stroke || 'black';
			var thickness = specs.thickness || 1.5;
			var name = specs.name || 'shape';
			var selected = false;
			var draw = function(ctx){
				if(selected){
					ctx.setLineDash([5]);
					ctx.strokeStyle = '#00f';
				}else{
					ctx.setLineDash([]);
					ctx.strokeStyle = stroke;
				}
				//ctx.strokeStyle = stroke;
				ctx.lineWidth = thickness;
				ctx.fillStyle = fill;
			};
			var contains = function(p){return distance(p) < 10;};
			var distance = function(p){return Infinity;};
			var closestPointTo = function(p){return point(0,0);}
			var getSpecs = function(){return {};};
			var repositionPoint = function(p, oldSpecs, newSpecs){};
			var onmouseover = sender().add(function(e){
				stroke = '#f00';
			});
			var passesFilter = function(){return true;};
			var onchange = sender();
			var ondrag = sender();
			var changer = {};
			var getChanger = function(){
				var o = {};
				for(var f in changer){
					if(changer.hasOwnProperty(f)){
						o[f] = (function(f_){
							return function(){
								var oldSpecs = getSpecs();
								changer[f_].apply(null, arguments);
								onchange(oldSpecs, getSpecs());
							};
						})(f)
					}
				}
				return o;
			};
			var onmouseout = sender().add(function(e){
				stroke = 'black';
			});
			var onclick = sender();

			this.expose({
				draw: draw,
				contains: contains,
				onmouseover: onmouseover,
				onmouseout: onmouseout,
				onclick: onclick,
				ondrag: ondrag,
				onchange: onchange,
				setName: function(n){name = n;},
				toString:function(){return '['+name+']';},
				getSpecs: getSpecs,
				getChanger: getChanger,
				dragTo: function(p){ondrag(p);},
				repositionPoint: function(p, oldSpecs, newSpecs){return repositionPoint(p, oldSpecs, newSpecs);},
				passesFilter: function(f){return passesFilter(f);},
				setSelected: function(b){selected = b;}
			});
			this.extend('circle', function(_specs){
				var center = _specs.center || point(0,0);
				var r = _specs.r || 1;
				
				draw = this.override(draw, function(ctx){
					this(ctx);
					ctx.beginPath();
					ctx.arc(center.x, center.y, r, 0, 2*Math.PI);
					ctx.closePath();
					ctx.stroke();
				});

				distance = function(p){
					return Math.abs(center.minus(p).mod() - r);
				};

				closestPointTo = function(p){
					return center.plus(p.minus(center).unit().scale(r));
				};

				passesFilter = function(f){return f == shapeFilter.CIRCLE || f == shapeFilter.ALL;};

				changer = {
					setR: function(r_){r = r_;},
					setCenter: function(c_){
						center = c_;
					}
				};

				getSpecs = function(){
					return {
						center:center,
						r:r
					};
				};

				repositionPoint = function(p, oldSpecs, newSpecs){
					if(oldSpecs.center.equals(newSpecs.center)){
						return oldSpecs.center.plus(p.minus(oldSpecs.center).scale(newSpecs.r/oldSpecs.r));
					}
					else{
						return p.plus(newSpecs.center.minus(oldSpecs.center));
					}
				};
				this.expose({
					draw:draw,
					closestPointTo: closestPointTo,
					getSpecs: getSpecs
				});
			});
			this.extend('line', function(_specs){
				var p1 = _specs.p1 || point(0,0);
				var p2 = _specs.p2 || point(1,0);

				draw = this.override(draw, function(ctx){
					this(ctx);
					if(!p1.equals(p2)){
						var onEdges = intersectWithBox(p1, p2);
						if(onEdges.p1 == null || onEdges.p2 == null){
							console.log("nope");
						}
						ctx.beginPath();
						ctx.moveTo(onEdges.p1.x, onEdges.p1.y);
						ctx.lineTo(onEdges.p2.x, onEdges.p2.y);
						ctx.closePath();
						ctx.stroke();
					}
					
				});

				var p1ToClosestPoint = function(p){
					var x = p.minus(p1), y = p2.minus(p1);
					var dot = x.dot(y);
					return y.unit().scale(dot/y.mod());
				};
				closestPointTo = function(p){
					return p1.plus(p1ToClosestPoint(p));
				};
				distance = function(p){
					return p.minus(closestPointTo(p)).mod();
				};
				passesFilter = function(f){return f == shapeFilter.LINE || f == shapeFilter.ALL;};

				getSpecs = function(){
					return {
						p1:p1,
						p2:p2
					};
				};

				changer = {
					setP1:function(p){p1 = p;},
					setP2:function(p){p2 = p;},
					translateBy: function(d){
						p1 = p1.plus(d);
						p2 = p2.plus(d);
					},
					moveTo: function(p){
						if(p.minus(p1).dot(p2.minus(p1)) > 0){
							p2 = p;
						}else{
							p2 = p1.plus(p1.minus(p));
						}
					}
				};

				repositionPoint = function(p, oldSpecs, newSpecs){
					if(oldSpecs.p1.equals(newSpecs.p1)){
						var sign = p.minus(oldSpecs.p1).dot(oldSpecs.p2.minus(oldSpecs.p1)) >=0 ? 1: -1;
						return newSpecs.p1.plus(newSpecs.p2.minus(newSpecs.p1).unit().scale(sign * p.minus(newSpecs.p1).mod()));
					}
					if(!oldSpecs.p2.equals(newSpecs.p2)){
						return p.plus(newSpecs.p2.minus(oldSpecs.p2));
					}
					var sign = p.minus(oldSpecs.p2).dot(oldSpecs.p1.minus(oldSpecs.p2)) >=0 ? 1: -1;
					return newSpecs.p2.plus(newSpecs.p1.minus(newSpecs.p2).unit().scale(sign * p.minus(newSpecs.p2).mod()));
				};

				this.expose({
					draw:draw,
					closestPointTo: closestPointTo,
					getSpecs: getSpecs
				});
			});
			this.extend('point',function(_specs){
				var loc = _specs.location || point(0,0);
				
				draw = this.override(draw, function(ctx){
					this(ctx);
					ctx.fillStyle = ctx.strokeStyle;
					ctx.strokeStyle = 'transparent';
					ctx.beginPath();
					ctx.arc(loc.x, loc.y, 2*thickness, 0, 2*Math.PI);
					ctx.closePath();
					ctx.fill();
				});

				distance = function(p){
					return loc.minus(p).mod();
				};

				closestPointTo = function(p){return loc;};

				passesFilter = function(f){return f == shapeFilter.POINT || f == shapeFilter.ALL;};

				changer = {
					setLocation: function(l){loc = l;}
				};

				getSpecs = function(){
					return {
						location: loc
					};
				};
				this.expose({
					draw:draw,
					closestPointTo: closestPointTo,
					getSpecs: getSpecs
				});
			});
		});



		var shapes = [];

		var shapeWrappers = [];

		var wrapperBelongingTo = function(s){
			return shapeWrappers.filter(function(w){return w.shape == s;})[0].wrapper;
		};

		var shapeBelongingTo = function(w){
			return shapeWrappers.filter(function(w_){return w_.wrapper == w;})[0].shape;
		};

		var draw = throttle(function(){
			c.width = w;
			shapes.map(function(s){
				s.draw(context);
			});
		}, 2);

		var onmouseovershape = function(s, e){};

		var onclickshape = function(s, e){};

		var onmousedownonshape = function(s, e){};

		var onmouseovernotshape = function(e){};

		var onmouseoverintersection = function(s1, s2, e){};

		var onclickintersection = function(i, e){};

		var onmouseup = function(e){};

		var onclicknotshape = function(e){};

		var addShape = function(s, toBeExcludedFromMouseEvents){
			shapes.map(function(ss){
				intersections.makeForShapes(s, ss);
			});
			s.setName('shape'+(shapes.length));
			s.toBeExcludedFromMouseEvents = toBeExcludedFromMouseEvents || false;
			shapes.push(s);
			var onremove = sender();
			var shapeWrapperPair;
			var wrapper = {
				remove: function(){
					var index = shapes.indexOf(s);
					var index2 = shapeWrappers.indexOf(shapeWrapperPair);
					if(index != -1){
						shapes.splice(index, 1);
						shapeWrappers.splice(index2, 1);
						intersections.removeForShape(s);
						onremove();
						draw();
					}
				},
				onmouseover:function(f){s.onmouseover.add(f);},
				onmouseout: function(f){s.onmouseout.add(f);},
				onclick: function(f){s.onclick.add(f);},
				onchange: function(f){s.onchange.add(f);},
				ondrag: function(f){s.ondrag.add(f);},
				onremove: function(f){onremove.add(f);},
				dragTo: function(p){s.dragTo(p);},
				getChanger: s.getChanger,
				getSpecs: s.getSpecs,
				exclude: function(b){s.toBeExcludedFromMouseEvents = b;},
				closestPointTo: s.closestPointTo,
				repositionPoint: s.repositionPoint
			};
			shapeWrapperPair = {
				shape: s,
				wrapper: wrapper
			};
			shapeWrappers.push(shapeWrapperPair);
			return wrapper;
		};

		var intersections = (function(){
			var all = [];
			var intersection = function(s1, s2, calculate){
				return {
					s1:s1,
					s2:s2,
					calculate:calculate
				};
			};
			var getForShapes = function(s1, s2, p){
				var candidates = all.filter(function(i){return i.s1 == s1 && i.s2 == s2 || i.s2 == s1 && i.s1 == s2;});
				var smallestDistance = Math.min.apply(null, candidates.map(function(c){
					return (c.calculate()||point(0,0)).minus(p).mod();
				}));
				var result = candidates.filter(function(c){return (c.calculate()||point(0,0)).minus(p).mod() == smallestDistance;})[0];
				if(result.calculate()){
					return result;
				}
				return null;
			};
			var makeForShapes = function(s1, s2){
				if(s1.passesFilter(shapeFilter.LINE) && s2.passesFilter(shapeFilter.LINE)){
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectLines(s1specs.p1, s1specs.p2, s2specs.p1, s2specs.p2);
					}));
				}else if(s1.passesFilter(shapeFilter.CIRCLE) && s2.passesFilter(shapeFilter.CIRCLE)){
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectCircles(s1specs.center, s1specs.r, s2specs.center, s2specs.r, 0);
					}));
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectCircles(s1specs.center, s1specs.r, s2specs.center, s2specs.r, 1);
					}));
				}else if(s1.passesFilter(shapeFilter.LINE) && s2.passesFilter(shapeFilter.CIRCLE)){
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectLineAndCircle(s1specs.p1, s1specs.p2, s2specs.center, s2specs.r, 0);
					}));
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectLineAndCircle(s1specs.p1, s1specs.p2, s2specs.center, s2specs.r, 1);
					}));
				}else if(s1.passesFilter(shapeFilter.CIRCLE) && s2.passesFilter(shapeFilter.LINE)){
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectLineAndCircle(s2specs.p1, s2specs.p2, s1specs.center, s1specs.r, 0);
					}));
					all.push(intersection(s1, s2, function(){
						var s1specs = s1.getSpecs(), s2specs = s2.getSpecs();
						return intersectLineAndCircle(s2specs.p1, s2specs.p2, s1specs.center, s1specs.r, 1);
					}));
				}
				else{
					all.push(intersection(s1, s2, function(){return null;}));
				}
				
			};
			var removeForShape = function(s){
				all = all.filter(function(i){return i.s1 != s && i.s2 != s;});
			};
			return {
				getForShapes:getForShapes,
				makeForShapes:makeForShapes,
				removeForShape: removeForShape
			};
		})();

		var selection = (function(){
			var all = [];
			var addShape = function(w){
				var s = shapeBelongingTo(w);
				s.setSelected(true);
				all.push(s);
			};
			var clear = function(){
				all.map(function(s){s.setSelected(false);});
				all = [];
			};
			var removeAll = function(){
				all.map(function(s){wrapperBelongingTo(s).remove();});
				clear();
			};
			return {
				addShape: addShape,
				clear: clear,
				removeAll:removeAll
			};
		})();

		var mouseActionHandler = function(doToHitShape, doToNotHitShape, doIfNotHitShape, doToHitIntersection, drawAfter){
			doToHitShape = doToHitShape || function(){};
			doToNotHitShape = doToNotHitShape || function(){};
			doIfNotHitShape = doIfNotHitShape || function(){};
			doToHitIntersection = doToHitIntersection || function(){};
			var toReturn = function(e){
				var hitPoints, hitShape, hitIntersection, intersectingShape1, intersectingShape2, hitShapes = [];
				shapes.map(function(s){
					if(!s.toBeExcludedFromMouseEvents && s.passesFilter(currentMouseFilter) && s.contains(point(e.clientX, e.clientY))){
						hitShapes.push(s);
						
					}else{
						doToNotHitShape(s, e);
					}
				});
				if(hitShapes.length == 0){
					doIfNotHitShape(e);
				}else{
					hitPoints = hitShapes.filter(function(s){return s.passesFilter(shapeFilter.POINT);});
					if(hitPoints.length > 0){
						doToHitShape(hitPoints[hitPoints.length - 1], e);
					}else{
						if(hitShapes.length == 1){
							doToHitShape(hitShapes[hitShapes.length - 1], e);
						}else{
							hitIntersection = intersections.getForShapes(hitShapes[hitShapes.length - 2], hitShapes[hitShapes.length - 1], point(e.clientX, e.clientY));
							if(hitIntersection){
								doToHitIntersection((function(i){
									return {
										s1: wrapperBelongingTo(i.s1),
										s2: wrapperBelongingTo(i.s2),
										calculate: i.calculate
									};
								})(hitIntersection), e);
							}else{
								doToHitShape(hitShapes[hitShapes.length - 1], e);
							}
							
						}
					}
					
				}
				if(drawAfter){
					draw();
				}
				
			};
			return toReturn;
		};

		var moveHandler = mouseActionHandler(
			function(s, e){
				s.onmouseover(e);
				onmouseovershape(wrapperBelongingTo(s), e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				onmouseovernotshape(e);
			},
			function(i, e){
				onmouseoverintersection(i, e);
			},
			true
		);

		var downHandler = mouseActionHandler(
			function(s, e){
				onmousedownonshape(wrapperBelongingTo(s), e);
			}
		);

		var clickHandler = mouseActionHandler(
			function(s, e){
				s.onclick(e);
				onclickshape(wrapperBelongingTo(s), e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				onclicknotshape(e);
			},
			function(i, e){
				onclickintersection(i, e);
			}
			
		);

		c.addEventListener('mousemove', moveHandler);

		c.addEventListener('mousedown', downHandler);

		c.addEventListener('mouseup', function(e){
			onmouseup(e);
			draw();
		});

		c.addEventListener('click', clickHandler);

		return {
			addCircle: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.circle({}, specs), toBeExcludedFromMouseEvents);
			},
			addPoint: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.point({}, specs), toBeExcludedFromMouseEvents);
			},
			addLine: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.line({}, specs), toBeExcludedFromMouseEvents);
			},
			onmouseovershape: function(f){onmouseovershape = f || function(){};},
			onmousedownonshape: function(f){onmousedownonshape = f || function(){};},
			onmouseovernotshape: function(f){
				onmouseovernotshape = f || function(){};
			},
			onmouseoverintersection: function(f){onmouseoverintersection = f || function(){};},
			onclickintersection: function(f){onclickintersection = f || function(){};},
			onclickshape: function(f){onclickshape = f || function(){};},
			onclicknotshape: function(f){onclicknotshape = f || function(){};},
			haspointer: function(){c.style.cursor = "-webkit-grab";},
			isgrabbing: function(){c.style.cursor = "-webkit-grabbing";},
			onmouseup: function(f){onmouseup = f || function(){};},
			hasnopointer: function(){
				c.style.cursor = "default";
			},
			setMouseFilter: function(f){currentMouseFilter = f;},
			mouseFilter: shapeFilter,
			selectShape: function(s){selection.addShape(s);},
			clearSelection: function(){selection.clear();},
			removeSelection: function(){selection.removeAll();}
		};

	})(w,h);


	var structure = {
		point: function(canvasPoint, canvasShape){
			var putOnShapeClosestTo;
			if(!canvasShape){
				canvasPoint.ondrag(function(p){
					canvasPoint.getChanger().setLocation(p);
				});
			}else{
				putOnShapeClosestTo = function(p){
					canvasPoint.getChanger().setLocation(canvasShape.closestPointTo(p));
				};
				canvasPoint.ondrag(putOnShapeClosestTo);
				putOnShapeClosestTo(canvasPoint.getSpecs().location);
				canvasShape.onchange(function(oldSpecs, newSpecs){
					canvasPoint.getChanger().setLocation(canvasShape.repositionPoint(canvasPoint.getSpecs().location, oldSpecs, newSpecs));
				});
				canvasShape.onremove(function(){
					canvasPoint.remove();
				});
			}
			
			return {
				onchange: function(f){canvasPoint.onchange(f);}
			};
		},
		pointOnIntersection: function(canvasPoint, i){
			var setLocation = function(){
				var loc = i.calculate();
				if(loc){
					canvasPoint.getChanger().setLocation(loc);
				}
			};
			console.log(i.s1, i.s2);
			i.s1.onchange(setLocation);
			i.s2.onchange(setLocation);
			i.s1.onremove(canvasPoint.remove);
			i.s2.onremove(canvasPoint.remove);
		},
		circle: function(canvasPointCenter, canvasCircle, canvasPointBoundary){
			var setAnew;
			if(!canvasPointBoundary){
				canvasPointCenter.onchange(function(oldSpecs, newSpecs){
					canvasCircle.getChanger().setCenter(newSpecs.location);
				});
				canvasPointCenter.onremove(function(){
					canvasCircle.remove();
				});
				canvasCircle.ondrag(function(p){
					var center = canvasCircle.getSpecs().center;
					var changer = canvasCircle.getChanger();
					changer.setR(center.minus(p).mod());
				});
			}else{
				setAnew = function(c,b){
					var changer = canvasCircle.getChanger();
					changer.setCenter(c);
					changer.setR(b.minus(c).mod());
				}
				canvasPointCenter.onchange(function(oldSpecs, newSpecs){
					setAnew(newSpecs.location, canvasPointBoundary.getSpecs().location);
				});
				canvasPointCenter.onremove(function(){
					canvasCircle.remove();
				});
				canvasPointBoundary.onchange(function(oldSpecs, newSpecs){
					setAnew(canvasPointCenter.getSpecs().location, newSpecs.location);
				});
				canvasPointBoundary.onremove(function(){
					canvasCircle.remove();
				});
			}
		},
		line: function(canvasPoint1, canvasLine, canvasPoint2){
			var setAnew;
			if(!canvasPoint2){
				canvasPoint1.onchange(function(oldSpecs, newSpecs){
					var changer = canvasLine.getChanger();
					var diff = newSpecs.location.minus(oldSpecs.location);
					changer.translateBy(diff);
				});
				canvasLine.ondrag(function(p){
					canvasLine.getChanger().moveTo(p);
				});
				canvasPoint1.onremove(function(){canvasLine.remove();});
			}else{
				setAnew = function(p1, p2){
					var changer = canvasLine.getChanger();
					changer.setP1(p1);
					changer.setP2(p2);
				};
				canvasPoint1.onchange(function(oldSpecs, newSpecs){
					setAnew(newSpecs.location, canvasPoint2.getSpecs().location);
				});
				canvasPoint1.onremove(function(){canvasLine.remove();});
				canvasPoint2.onchange(function(oldSpecs, newSpecs){
					setAnew(canvasPoint1.getSpecs().location, newSpecs.location);
				});
				canvasPoint2.onremove(function(){canvasLine.remove();});
			}
		}
	};

	var action = {
		doNothing: function(){
			canvas.setMouseFilter(canvas.mouseFilter.ALL);
			canvas.onclickshape();
			canvas.onclicknotshape();
			canvas.onmousedownonshape(action.startMoving);
			canvas.onmouseovershape(canvas.haspointer);
			canvas.onmouseoverintersection();
			canvas.onclickintersection(function(){console.log("clicked intersection");});
			canvas.onmouseovernotshape(canvas.hasnopointer);
			canvas.onmouseup();
		},
		select: function(stop){
			canvas.setMouseFilter(canvas.mouseFilter.ALL);
			canvas.onmousedownonshape();
			canvas.onmouseovershape(canvas.hasnopointer);
			canvas.onmouseovernotshape(canvas.hasnopointer);
			canvas.onclickshape(function(s, e){
				canvas.selectShape(s);
			});
			canvas.onclicknotshape(function(e){
				canvas.clearSelection();
			});
			return function(){
				canvas.clearSelection();
				stop();
			};
		},
		startMoving: function(s, e){
			var doMove = function(e){
				canvas.isgrabbing();
				s.dragTo(point(e.clientX, e.clientY));
			};

			canvas.onmouseup(action.doNothing);
			canvas.onmouseovershape(function(s, e){doMove(e);});
			canvas.onmouseovernotshape(doMove);
			canvas.onmouseoverintersection(function(i,e){doMove(e);});
			doMove(e);
		},
		makePointStructure: function(res, stop){
			var p = canvas.addPoint({
				location: point(200,200)
			}, true);
			canvas.onmousedownonshape();
			canvas.onmouseovershape(function(s, e){
				p.getChanger().setLocation(s.closestPointTo(point(e.clientX, e.clientY)));
			});
			canvas.onmouseovernotshape(function(e){
				p.getChanger().setLocation(point(e.clientX, e.clientY));
			});
			canvas.onmouseoverintersection(function(i, e){
				p.getChanger().setLocation(i.calculate());
				
			});
			canvas.onclickshape(function(s, e){
				
				console.log("clicked shape");
				res(structure.point(p, s));
				p.exclude(false);
				stop();
			});
			canvas.onclickintersection(function(i){
				res(structure.pointOnIntersection(p, i));
				p.exclude(false);
				stop();
			});
			canvas.onclicknotshape(function(e){
				
				
				res(structure.point(p));
				p.exclude(false);
				stop();
			});
			return function(){
				p.remove();
				stop();
			};
		},
		makeCircleStructure: function(res, stop){
			var revert = stop;
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			var chosenCenter, growCircle, circle;
			canvas.onmouseovershape();
			canvas.onmousedownonshape();
			
			canvas.onclickshape(function(s, e){
				chosenCenter = s;
				circle = canvas.addCircle({center:chosenCenter.getSpecs().location,r:20});
				growCircle = function(p){circle.getChanger().setR(p.minus(chosenCenter.getSpecs().location).mod());};
				canvas.onmouseovernotshape(function(e){
					growCircle(point(e.clientX, e.clientY));
				});
				canvas.onmouseovershape(function(s, e){
					growCircle(s.closestPointTo(point(e.clientX, e.clientY)));
				});
				canvas.onclicknotshape(function(e){
					res(structure.circle(chosenCenter, circle));
					canvas.setMouseFilter(canvas.mouseFilter.ALL);
					stop();
				});
				canvas.onclickshape(function(s, e){
					res(structure.circle(chosenCenter, circle, s));
					canvas.setMouseFilter(canvas.mouseFilter.ALL);
					stop();
				});
				revert = function(){
					circle.remove();
					stop();
				};
			});
			return function(){
				revert();
			};
		},
		makeLineStructure: function(res, stop){
			var revert = stop;
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			var chosenP1, moveLine, line;
			canvas.onmouseovershape();
			canvas.onmousedownonshape();
			canvas.onclickshape(function(s, e){
				chosenP1 = s;
				line = canvas.addLine({p1:chosenP1.getSpecs().location, p2:chosenP1.getSpecs().location.plus(point(100,0))});
				moveLine = function(p){line.getChanger().moveTo(p);};
				canvas.onmouseovernotshape(function(e){
					moveLine(point(e.clientX, e.clientY));
				});
				canvas.onmouseovershape(function(s, e){
					moveLine(s.closestPointTo(point(e.clientX, e.clientY)));
				});
				canvas.onclicknotshape(function(e){
					res(structure.line(chosenP1, line));
					canvas.setMouseFilter(canvas.mouseFilter.ALL);
					stop();
				});
				canvas.onclickshape(function(s, e){
					res(structure.line(chosenP1, line, s));
					canvas.setMouseFilter(canvas.mouseFilter.ALL);
					stop();
				});
				revert = function(){
					line.remove();
					stop();
				};
			});
			return function(){
				revert();
			};
		}
	};

	var button = (function(){
		var x=20,y=20;
		var addClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class') + " "+name);
		};
		var removeClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class').split(/[\s]+/g).filter(function(c){return c!=name;}).join(' '));
		};
		var button = function(a, className){
			var b = makeNode("<div id='1' class='button"+(className?" "+className:"")+"' style='left:"+x+"px;top:"+y+"px'></div>", function(div){
				var makeActive = function(){addClass(div, 'active');};
				var makeNonActive = function(){removeClass(div, 'active');};
				var normalOnClick = function(e){
					var stop;
					e.preventDefault();
					makeActive();
					stop = a(function(){
						makeNonActive();
						div.onclick = normalOnClick;
					});
					if(stop){
						div.onclick = function(){
							stop();
							makeNonActive();
							div.onclick = normalOnClick;
						};
					}
					
				};
				div.onclick = normalOnClick;
				document.body.appendChild(div);
			});
			x+=40;
		};
		return button;
	})();

	button(function(deactivateButton){
		return action.makePointStructure(function(p){
			
		}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "point");

	button(function(deactivateButton){
		return action.makeCircleStructure(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "circle");

	button(function(deactivateButton){
		return action.makeLineStructure(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "line");

	button(function(deactivateButton){
		return action.select(function(){
			action.doNothing();
			deactivateButton();
		});
		
	});
	button(function(deactivateButton){
		canvas.removeSelection();
		deactivateButton();
	}, "remove");

	action.doNothing();

})(document, document.body.offsetWidth, document.body.offsetHeight);
</script>
</body>
</html>