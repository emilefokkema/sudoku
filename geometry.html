<html>
<head>
<style>
.button {
	width: 30px;
	height: 30px;
	background-color: #ddd;
	position: absolute;
	border-radius: 3px;
	border: 1px solid #aaa;
}
.button:hover
{
	border: 1px solid #000;
	
}
.point {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"15\" r=\"3\" fill=\"black\" /></svg>");
}
.circle {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"15\" r=\"10\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.hide {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"15\" cy=\"15\" r=\"10\" stroke=\"rgba(0,0,0,0.15)\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.line {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"2\" y1=\"24\" x2=\"28\" y2=\"6\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.active {
	border: 1px solid #f00;
	background-color: #daa;
}
.remove {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"4\" y1=\"26\" x2=\"26\" y2=\"4\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/><line x1=\"4\" y1=\"4\" x2=\"26\" y2=\"26\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
.perpendicular {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"11\" y1=\"2\" x2=\"24\" y2=\"28\" stroke=\"red\" fill=\"transparent\" stroke-width=\"2\"/><line x1=\"2\" y1=\"29\" x2=\"28\" y2=\"14\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/><circle cx=\"14\" cy=\"8\" r=\"3\" fill=\"black\" /></svg>");
}
.locus {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke=\"red\" stroke-width=\"1.5\" fill=\"transparent\" d=\"M 18.929260695298456 5.502867238221041 L 17.9771513180343 4.991515282163174 L 16.919126322318334 4.763699684015554 L 15.772963089667119 4.8201020443831215 L 14.55987915528993 5.15145458076139 L 13.304086293056358 5.738983090875893 L 12.03222869447725 6.555182998085298 L 10.772720478076911 7.56489923714855 L 9.555001560479592 8.726670060712665 L 8.408734111269538 9.994285609351934 L 7.362964282468346 11.318504616359265 L 6.445275557109315 12.648867175289455 L 5.6809608346148055 13.935538273807346 L 5.09224022859794 15.13111590310953 L 4.697550492117858 16.19233901666481 L 4.510930035080081 17.081634380068444 L 4.541520718221396 17.768447288473208 L 4.793204086885476 18.23030901552261 L 5.264385560613327 18.453603414909736 L 5.947935458652328 18.434005980411353 L 6.831290771509743 18.176580493323748 L 7.896716451463691 17.695530725349457 L 9.12171986369558 17.01361707973801 L 10.479607088003231 16.1612601009954 L 11.940165156832638 15.175364034154258 L 13.47045021509796 14.097903667388513 L 15.035658130503453 12.974326188402838 L 16.60005138763236 11.85182642278259 L 18.127914256861438 10.777558364874054 L 19.58450730306209 9.796848196966547 L 20.93699232067871 8.95147393916391 L 22.155299750390856 8.278074482266414 L 23.212912515103366 7.806746114370721 L 24.08754294522151 7.559877924084397 L 24.76168295187425 7.55126888893132 L 25.223011733068198 7.785559342209946 L 25.464649921250352 8.257998215751417 L 25.48525404431784 8.954555382372263 L 25.288950307413664 9.852376000859511 L 24.885111836194767 10.92056144116818 L 24.287988480613716 12.121249578081443 L 23.516202895225426 13.410956409001939 L 22.592130733615573 14.742131463141256 L 21.54118628444775 16.064871664927402 L 20.39103762091607 17.328732474072932 L 19.17077724640022 18.484571458916342 L 17.9100752383929 19.48635810169966 L 16.6383419929875 20.29288463577377 L 15.38392685802324 20.86931604293401 L 14.173377250703876 21.1885228790817 L 13.030780351726367 21.232148154413277 L 11.977206247064636 20.99136880474892 L 11.030267569318555 20.46732302534829 L 10.203806411809333 19.671186518670552 L 9.507714704349219 18.6238931166033 L 8.947889513426611 17.35550783655522 L 8.526320028826616 15.904272773153657 L 8.241298488730965 14.315357875404406 L 8.08774313343268 12.639359199504426 L 8.05761760779065 10.93059628529565 L 8.140428179739773 9.245267556968805 L 8.323777808971325 7.639527836990769 L 8.593954562281734 6.167555000028869 L 8.936531177015674 4.879673373995574 L 9.336952737895798 3.8205996945903102 L 9.781090440721774 3.027873298357254 L 10.255741223957408 2.5305259398438418 L 10.74905558251762 2.3480383605035495 L 11.250879037663022 2.4896208094438945 L 11.752996401172918 2.9538434670231197 L 12.249272001542131 3.728630546570706 L 12.735683282839414 4.7916191750142065 L 13.210249483981938 6.110871425641063 L 13.672861297095302 7.645915543416557 L 14.125021332399996 9.349080899307987 L 14.56950873787721 11.167080939977177 L 15.009984304397614 13.042789724685042 L 15.450554720730741 14.917150867853572 L 15.895316241662101 16.73115307207226 L 16.34789883729876 18.427804105668784 L 16.811031872838306 19.954035133404975 L 17.286151526305268 21.26246974649462 L 17.773068518088756 22.312996773076314 L 18.269712360866222 23.074092815698506 L 18.77196532906557 23.52384921642111 L 19.273595804723676 23.650668484462003 L 19.766296712668996 23.453606771968353 L 20.23983055878561 22.942351343791547 L 20.682278286972718 22.136834722035378 L 21.080384933791574 21.0664998475767 L 21.419991043584428 19.76924274349287 L 21.686535162595774 18.290070362681007 L 21.865609596981326 16.67952116083261 L 21.943549117275914 14.991904110718972 L 21.90803051925869 13.283418078492598 L 21.7486599805479 11.61021750118921 L 21.457525027304015 10.026491997936681 L 21.029688659334976 8.582626858847169 L 20.463604756878226 7.323508312654049 L 19.76143626006349 6.287032187456054\"></path><circle cx=\"18.929260695298456\" cy=\"5.502867238221041\" r=\"3\" fill=\"black\" /></svg>");
}
.bisect {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"5\" y1=\"0\" x2=\"20\" y2=\"30\" stroke=\"red\" fill=\"transparent\" stroke-width=\"2\"/><circle cx=\"8\" cy=\"21\" r=\"3\" fill=\"black\" /><circle cx=\"20\" cy=\"15\" r=\"3\" fill=\"black\" /></svg>");
}
.label:before {
	position: absolute;
	left: 0px;
	top:0px;
	font-family: Verdana;
	font-size: 20px;
	color: #000;
	content: "A";
}
.svg:before {
	position: absolute;
	left: 0px;
	top:5px;
	font-family: Verdana;
	font-size: 8px;
	color: #000;
	content: "<svg>";
}
.reflect-line {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><line x1=\"5\" y1=\"0\" x2=\"20\" y2=\"30\" stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/><circle cx=\"8\" cy=\"21\" r=\"3\" fill=\"red\" /><circle cx=\"20\" cy=\"15\" r=\"3\" fill=\"black\" /></svg>");
}
.select {
	background-image: url("data:image/svg+xml;utf8,<svg width=\"30\" height=\"30\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"6\" width=\"26\" height=\"18\" stroke=\"black\" stroke-dasharray=\"3,2\" fill=\"transparent\" stroke-width=\"2\"/></svg>");
}
</style>
</head>
<body style="margin:0px;padding:0px">
<script src="makeModule.js"></script>
<script src="makeNode.js"></script>
<script>
(function(document, w,h){
	Array.prototype.lastMin = function(amount){
		var result, m, min = Infinity;
		for(var i = 0; i<this.length;i++){
			m = amount(this[i]);
			if(m <= min){
				min = m;
				result = this[i];
			}
		}
		return result;
	};
	var throttle = function(f, interval){
		var going = false;
		return function(){
			if(!going){
				var args = arguments;
				going = true;
				setTimeout(function(){
					f.apply(null, args);
					going = false;
				}, interval);
			}
		};
	};
	var sender = function(){
		var todo= [];
		var f = function(){
			var args = arguments;
			todo.map(function(g){
				g.apply(null, args);
			});
		};
		f.add = function(g){todo.push(g);return f;};
		return f;
	};
	var point = function(x,y){
		
		return {
			x:x,
			y:y,
			minus: function(p){return point(x - p.x, y - p.y);},
			plus: function(p){return point(x + p.x, y + p.y);},
			cross:function(p){return x*p.y - y*p.x;},
			mod: function(){return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));},
			scale: function(r){return point(r*x, r*y);},
			unit: function(){return this.scale(1/this.mod());},
			toString: function(){return "("+x+","+y+")";},
			equals: function(p){return this == p|| (x == p.x && y == p.y);},
			matrix:function(a,b,c,d){return point(a*x+b*y,c*x+d*y);},
			dot:function(p){return x*p.x + y*p.y;}
		};
	};
	var copySet = function(origArray, mapper){
		var set = function(o, i){
			return {
				orig: o,
				copy:mapper(o,i)
			};
		};
		var all = origArray.map(set);
		return {
			copyOf: function(o){
				for(var i=0;i<all.length;i++){
					if(all[i].orig == o){
						return all[i].copy;
					}
				}
				return null;
			},
			originalOf:function(c){
				for(var i=0;i<all.length;i++){
					if(all[i].copy == c){
						return all[i].orig;
					}
				}
				return null;
			},
			allCopies: function(){return all.map(function(o){return o.copy;});},
			addFor: function(o){
				var filtered = all.filter(function(s){return s.orig == o;});
				if(filtered.length == 0){
					newSet = set(o, all.length);
					all.push(newSet);
					return newSet.copy;
				}else{
					return filtered[0].copy;
				}
			},
			removeFor:function(o){
				var index = -1;
				for(var i=0;i<all.length;i++){
					if(all[i].orig == o){
						index = i;
					}
				}
				if(index != -1){
					all.splice(index, 1);
				}
			}
		};
	};
	var distinctArray = function(arr){
		var arr2 = arr.slice();
		var push = function(o){
			if(arr.indexOf(o) == -1){
				arr.push(o);
			}
		};
		arr.splice(0,arr.length);
		arr2.map(function(o){push(o);});
		return {
			arr:arr,
			push:push
		};
	};

	var intersectLines = function(p1,p2,q1,q2){
		var x1 = p2.minus(p1);
		var x2 = q2.minus(q1);
		var cross = x2.cross(x1);
		if(cross == 0){
			return null;
		}
		var st = q1.minus(p1).matrix(-x2.y, x2.x, -x1.y, x1.x).scale(1/cross);
		return p1.plus(p2.minus(p1).scale(st.x));
	};

	var intersectCircles = function(p1, r1, p2, r2, index){
		var sina, cosa, d = p1.minus(p2).mod();
		if(r1 + r2 < d || r1 + d < r2 || r2 + d < r1 || d == 0){
			return null;
		}else if(r1 + r2 == d){
			return p1.plus(p2.minus(p1).unit().scale(r1));
		}else{
			cosa = (r1 * r1 - r2 * r2 + d * d) / (2 * d * r1);
			sina = Math.sqrt(1 - cosa * cosa) * (index == 0 ? 1 : -1);
			return p1.plus(p2.minus(p1).unit().scale(r1).matrix(cosa, -sina, sina, cosa));
		}
	};

	var intersectLineAndCircle = function(p1, p2, c, r, index){
		var sina, cossign, cosa, x = c.minus(p1), y = p2.minus(p1);
		var cross, dot = x.dot(y);
		var closestToCenter = p1.plus(y.unit().scale(dot/y.mod()));
		var d = closestToCenter.minus(c).mod();
		if(d < 0.0000001){
			return c.plus(y.unit().scale(r * (index == 0 ? 1 : -1)));
		}else if(d > r){
			return null;
		}else if(d == r){
			return closestToCenter;
		}else{
			cossign = (x.cross(y) > 0 ? 1 : -1)
			cosa = (d / r) * cossign;
			
			sina = Math.sqrt(1 - cosa * cosa) * (index == 0 ? 1 : -1);
			return c.plus(closestToCenter.minus(c).unit().scale(r * cossign).matrix(cosa, -sina, sina, cosa));
		}
	};

	var reflectPointInLine = function(p1, p2, p3){
		var x = p2.minus(p1), y = p3.minus(p1), along = x.unit().scale(x.dot(y) / x.mod()), perp = y.minus(along);
		return p1.plus(along).plus(perp.scale(-1));
	};

	var intersectWithBox = (function(){
		
		var sides = [
			{p1:point(0,0), p2: point(w,0)},
			{p1:point(w,0), p2: point(w,h)},
			{p1:point(w,h), p2: point(0,h)},
			{p1:point(0,h), p2: point(0,0)}
		];
		var intersectWithSide = function(p1, p2, side){
			return intersectLines(p1, p2, side.p1, side.p2);
		};
		

		return function(p1, p2){
			if(p1.x == p2.x){
				return {p1:intersectWithSide(p1, p2, sides[0]), p2: intersectWithSide(p1, p2, sides[2])};
			}
			//if(p1.y == p2.y){
			return {p1:intersectWithSide(p1, p2, sides[1]), p2: intersectWithSide(p1, p2, sides[3])};
			//}
			
		};
	})();

	var shapeLogic = makeModule(function(specs){
		var getSpecs = function(){return {};},
			changer = {},
			useSpecs = function(_specs){},
			closestPointTo = function(p){return point(0,0);},
			repositionPoint = function(){},
			getChanger = function(){
				var o = {useSpecs:useSpecs};
				for(var f in changer){
					if(changer.hasOwnProperty(f)){
						o[f] = (function(f_){
							return function(){
								var oldSpecs = getSpecs();
								changer[f_].apply(null, arguments);
								onchange(oldSpecs, getSpecs());
							};
						})(f)
					}
				}
				return o;
			},
			distance = function(p){return Infinity;},
			onchange = sender(),
			passesFilter = function(f){return true;},
			available = true,
			onchangeavailability = sender(),
			getLabelLocation = function(){return point(0,0);},
			toString = function(){return '';},
			movePointAround = function(p){return [p];};
		this.expose({
			isAvailable: function(){return available;},
			makeAvailable: function(b){available = b;onchangeavailability(b);},
			onchangeavailability:function(f){onchangeavailability.add(f);},
			getSpecs: function(){return getSpecs();},
			getChanger: getChanger,
			closestPointTo: function(p){return closestPointTo(p);},
			repositionPoint: function(p, oldSpecs, newSpecs){return repositionPoint(p, oldSpecs, newSpecs);},
			onchange: function(f){
				onchange.add(f);
			},
			distance:function(p){return distance(p);},
			passesFilter: function(f){return passesFilter(f);},
			movePointAround: function(p){return movePointAround(p);},
			getLabelLocation:function(){return getLabelLocation();},
			toString:function(){return toString();}
		});
		this.extend('circle',function(){
			var center, r;
			useSpecs = function(_specs){
				center = _specs.center || point(0,0);
				r = _specs.r || 1;
			};
			useSpecs(specs);
			toString = function(){return 'circle('+center.toString()+','+r+')';};
			distance = function(p){
				return Math.abs(center.minus(p).mod() - r);
			};

			closestPointTo = function(p){
				return center.plus(p.minus(center).unit().scale(r));
			};

			changer = {
				setR: function(r_){r = r_;},
				setCenter: function(c_){
					center = c_;
				}
			};

			movePointAround = function(p){
				return Array.apply(null, new Array(100)).map(function(x,t){
					var cos = Math.cos(t*2*Math.PI / 100), sin = Math.sin(t*2*Math.PI / 100);
					return center.plus(p.minus(center).matrix(cos, -sin, sin, cos));
				});
			};

			passesFilter = function(f){return f == shapeFilter.CIRCLE || f == shapeFilter.ALL;};

			getSpecs = function(){
				return {
					center:center,
					r:r
				};
			};

			getLabelLocation = function(){
				var d = Math.sqrt(2) / 2;
				return center.plus(point(1,0).scale(r+2).matrix(d, d, -d, d));
			};

			repositionPoint = function(p, oldSpecs, newSpecs){
				if(oldSpecs.center.equals(newSpecs.center)){
					return oldSpecs.center.plus(p.minus(oldSpecs.center).scale(newSpecs.r/oldSpecs.r));
				}
				else{
					return p.plus(newSpecs.center.minus(oldSpecs.center));
				}
			};
			this.expose({changer:getChanger()});
		});
		this.extend('line',function(){
			var p1, p2;
			useSpecs = function(_specs){
				p1 = _specs.p1 || point(0,0);
				p2 = _specs.p2 || point(1,0);
			};
			toString = function(){return 'line('+p1.toString()+','+p2.toString()+')';};
			useSpecs(specs);
			var p1ToClosestPoint = function(p){
				var x = p.minus(p1), y = p2.minus(p1);
				var dot = x.dot(y);
				return y.unit().scale(dot/y.mod());
			};
			closestPointTo = function(p){
				return p1.plus(p1ToClosestPoint(p));
			};
			distance = function(p){
				return p.minus(closestPointTo(p)).mod();
			};
			getSpecs = function(){
				return {
					p1:p1,
					p2:p2
				};
			};

			changer = {
				setP1:function(p){p1 = p;},
				setP2:function(p){p2 = p;},
				translateBy: function(d){
					p1 = p1.plus(d);
					p2 = p2.plus(d);
				},
				moveTo: function(p){
					if(p.minus(p1).dot(p2.minus(p1)) > 0){
						p2 = p;
					}else{
						p2 = p1.plus(p1.minus(p));
					}
				},
				setFromP1: function(d){
					p2 = p1.plus(d);
				}
			};

			passesFilter = function(f){return f == shapeFilter.LINE || f == shapeFilter.ALL;};

			repositionPoint = function(p, oldSpecs, newSpecs){
				if(oldSpecs.p1.equals(newSpecs.p1)){
					var sign = p.minus(oldSpecs.p1).dot(oldSpecs.p2.minus(oldSpecs.p1)) >=0 ? 1: -1;
					return newSpecs.p1.plus(newSpecs.p2.minus(newSpecs.p1).unit().scale(sign * p.minus(newSpecs.p1).mod()));
				}
				if(!oldSpecs.p2.equals(newSpecs.p2)){
					return p.plus(newSpecs.p2.minus(oldSpecs.p2));
				}
				var sign = p.minus(oldSpecs.p2).dot(oldSpecs.p1.minus(oldSpecs.p2)) >=0 ? 1: -1;
				return newSpecs.p2.plus(newSpecs.p1.minus(newSpecs.p2).unit().scale(sign * p.minus(newSpecs.p2).mod()));
			};
			this.expose({changer:getChanger()});
		});
		this.extend('point',function(){
			var loc;
			useSpecs = function(_specs){
				loc = _specs.location || point(0,0);
			};
			toString = function(){return 'point'+loc.toString();};
			useSpecs(specs);
			distance = function(p){
				return loc.minus(p).mod();
			};

			closestPointTo = function(p){return loc;};

			passesFilter = function(f){return f == shapeFilter.POINT || f == shapeFilter.ALL;};

			changer = {
				setLocation: function(l){loc = l;}
			};

			passesFilter = function(f){return f == shapeFilter.POINT || f == shapeFilter.ALL;};

			getSpecs = function(){
				return {
					location: loc
				};
			};

			getLabelLocation = function(){return loc;};
			this.expose({changer:getChanger()});
		});
		this.extend('locus',function(){
			var pointSets = [], allPoints = [];
			useSpecs = function(_specs){};
			distance = function(p){
				return Math.min.apply(null, allPoints.map(function(pp){return pp.minus(p).mod();}));
			};
			toString = function(){return 'locus()';};
			closestPointTo = function(p){
				return allPoints.lastMin(function(pp){return pp.minus(p).mod();});
			};

			passesFilter = function(f){return f == shapeFilter.LOCUS || f == shapeFilter.ALL;};

			changer = {
				setPointSets: function(ps){
					pointSets = ps;
					allPoints = ps.reduce(function(a,b){return a.concat(b);},[]);
				}
			};

			getSpecs = function(){
				return {
					pointSets: pointSets
				};
			};
			this.expose({changer:getChanger()});
		});
	});

	var shapeFilter = {
		ALL: 0,
		POINT: 1,
		NONE:2,
		LINE:3,
		CIRCLE:4,
		LOCUS: 5
	};

	var intersectionSet = function(){
		var intersection = function(s1, s2, calculate, id){
			return {
				id:id,
				s1:s1,
				s2:s2,
				calculate:function(){
					return calculate(s1.getSpecs(), s2.getSpecs());
				}
			};
		};
		var intersectionKinds = [
			{
				matches:function(s1, s2){
					return s1.passesFilter(shapeFilter.LINE) && s2.passesFilter(shapeFilter.LINE);
				},
				makeForShapes: function(s1, s2){
					return [
						intersection(s1, s2, function(s1specs, s2specs){
							return intersectLines(s1specs.p1, s1specs.p2, s2specs.p1, s2specs.p2);
						}, 0)
					];
				}
			},{
				matches:function(s1, s2){
					return s1.passesFilter(shapeFilter.CIRCLE) && s2.passesFilter(shapeFilter.CIRCLE);
				},
				makeForShapes:function(s1, s2){
					return [0,1].map(function(i){
						return intersection(s1, s2, function(s1specs, s2specs){
							return intersectCircles(s1specs.center, s1specs.r, s2specs.center, s2specs.r, i);
						}, i);
					});
				}
			},{
				matches:function(s1, s2){
					return s1.passesFilter(shapeFilter.LINE) && s2.passesFilter(shapeFilter.CIRCLE) || s1.passesFilter(shapeFilter.CIRCLE) && s2.passesFilter(shapeFilter.LINE);
				},
				makeForShapes:function(s1, s2){
					if(s1.passesFilter(shapeFilter.LINE)){
						return [0,1].map(function(i){
							return intersection(s1, s2, function(s1specs, s2specs){
								return intersectLineAndCircle(s1specs.p1, s1specs.p2, s2specs.center, s2specs.r, i);
							}, i);
						});
					}else{
						return [0,1].map(function(i){
							return intersection(s1, s2, function(s1specs, s2specs){
								return intersectLineAndCircle(s2specs.p1, s2specs.p2, s1specs.center, s1specs.r, i);
							}, i);
						});
					}
				}
			}
		];
		var all = [];
		
		var getForShapes = function(s1, s2, p){
			var candidates = all.filter(function(i){return i.s1 == s1 && i.s2 == s2 || i.s2 == s1 && i.s1 == s2;});
			var result = candidates.lastMin(function(c){return (c.calculate()||point(0,0)).minus(p).mod();});
			if(result.calculate()){
				return result;
			}
			return null;
		};
		var getForShapesAndId = function(s1, s2, id){
			var candidates = all.filter(function(i){return i.s1 == s1 && i.s2 == s2 || i.s2 == s1 && i.s1 == s2;});
			return candidates.filter(function(i){return i.id == id;})[0];
		};
		var makeForShapes = function(s1, s2){
			for(var i=0;i<intersectionKinds.length;i++){
				if(intersectionKinds[i].matches(s1, s2)){
					intersectionKinds[i].makeForShapes(s1, s2).map(function(ii){
						all.push(ii);
					});
					return;
				}
			}
			all.push(intersection(s1, s2, function(){return null;}));
		};
		var removeForShape = function(s){
			all = all.filter(function(i){return i.s1 != s && i.s2 != s;});
		};
		return {
			getForShapes:getForShapes,
			getForShapesAndId:getForShapesAndId,
			makeForShapes:function(sarr){
				for(var i=0;i<sarr.length;i++){
					for(var j=i+1;j<sarr.length;j++){
						makeForShapes(sarr[i], sarr[j]);
					}
				}
			},
			removeForShape: removeForShape
		};
	};

	var canvas = (function(){
		var context, c = document.createElement('canvas');
		c.setAttribute('width', w);
		c.setAttribute('height', h);
		document.body.appendChild(c);
		context = c.getContext('2d');
		var ondraw = sender();
		var showHidden = false;

		var currentMouseFilter = shapeFilter.ALL;

		var shape = makeModule(function(specs){
			var fill = specs.fill || 'transparent';
			var stroke = specs.stroke || 'black';
			var changedStroke = stroke;
			var thickness = specs.thickness || 1.5;
			var name = specs.name || 'shape';
			var label = '';
			var selected = false;
			var hidden = false;
			var draw = function(ctx){
				if(selected){
					ctx.setLineDash([5]);
					ctx.strokeStyle = '#00f';
				}else{
					ctx.setLineDash([]);
					ctx.strokeStyle = changedStroke;
				}
				if(hidden){
					ctx.strokeStyle = '#bbb';
				}
				ctx.fillStyle = stroke;
				var labelloc = logic.getLabelLocation();
				ctx.font = "12px Verdana";
				ctx.fillText(label, labelloc.x + 5, labelloc.y - 5);
				ctx.lineWidth = thickness;
				ctx.fillStyle = fill;

			};
			var logic;
			var contains = function(p){return logic.distance(p) < 10;};
			var onmouseover = sender().add(function(e){
				changedStroke = '#f00';
			});
			var ondrag = sender();
			var onmouseout = sender().add(function(e){
				changedStroke = stroke;
			});
			var onclick = sender();
			var hideUnhide = function(){
				hidden = !hidden;
			};
			var getNewShapeLogic = function(sp){};
			var toSvg = function(){};
			var setSvgAttributes = function(svgEl){
				svgEl.setAttribute('stroke',stroke);
				svgEl.setAttribute('stroke-width',thickness);
				svgEl.setAttribute('fill',fill);
			};
			this.expose({
				draw: function(ctx){
					if(logic.isAvailable() && (!hidden || showHidden)){
						draw(ctx);
					}
				},
				getNewShapeLogic: function(){return getNewShapeLogic(logic.getSpecs());},
				isHidden:function(){return hidden;},
				isAvailable: function(){return logic.isAvailable();},
				contains: contains,
				makeAvailable: function(b){logic.makeAvailable(b);},
				onchangeavailability:function(f){logic.onchangeavailability(f);},
				onmouseover: onmouseover,
				onmouseout: onmouseout,
				onclick: onclick,
				ondrag: ondrag,
				onchange: function(f){logic.onchange(f);},
				setName: function(n){name = n;},
				toString:function(){return '['+name+']';},
				toConstructionString:function(){return logic.toString();},
				getSpecs: function(){return logic.getSpecs();},
				getChanger: function(){return logic.changer;},
				dragTo: function(p){ondrag(p);},
				repositionPoint: function(p, oldSpecs, newSpecs){return logic.repositionPoint(p, oldSpecs, newSpecs);},
				passesFilter: function(f){return logic.passesFilter(f);},
				setSelected: function(b){selected = b;},
				hideUnhide: hideUnhide,
				closestPointTo:function(p){return logic.closestPointTo(p);},
				movePointAround: function(p){return logic.movePointAround(p);},
				setLabel:function(txt){label = txt;},
				getLabelLocation:function(){return logic.getLabelLocation();},
				toSvg:function(){return toSvg();}
			});
			this.extend('circle', function(_specs){
				
				draw = this.override(draw, function(ctx){
					this(ctx);
					var sp = logic.getSpecs();
					ctx.beginPath();
					ctx.arc(sp.center.x, sp.center.y, sp.r, 0, 2*Math.PI);
					ctx.closePath();
					ctx.stroke();
				});

				name = specs.name || 'circle';

				getNewShapeLogic = function(sp){return shapeLogic.circle(sp);};

				logic = getNewShapeLogic(_specs);

				toSvg = function(){
					var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
					setSvgAttributes(circle);
					var sp = logic.getSpecs();
					circle.setAttribute('cx', sp.center.x);
					circle.setAttribute('cy', sp.center.y);
					circle.setAttribute('r', sp.r);
					return [circle];
				};
				
			});
			this.extend('line', function(_specs){

				draw = this.override(draw, function(ctx){
					this(ctx);
					var sp = logic.getSpecs();
					if(!sp.p1.equals(sp.p2)){
						var onEdges = intersectWithBox(sp.p1, sp.p2);
						
						ctx.beginPath();
						ctx.moveTo(onEdges.p1.x, onEdges.p1.y);
						ctx.lineTo(onEdges.p2.x, onEdges.p2.y);
						ctx.closePath();
						ctx.stroke();
					}
					
				});

				name = specs.name || 'line';

				getNewShapeLogic = function(sp){return shapeLogic.line(sp);};

				logic = getNewShapeLogic(_specs);

				toSvg = function(){
					var sp = logic.getSpecs();
					if(!sp.p1.equals(sp.p2)){
						var onEdges = intersectWithBox(sp.p1, sp.p2);
						var line = document.createElementNS('http://www.w3.org/2000/svg','line');
						setSvgAttributes(line);
						line.setAttribute('x1',onEdges.p1.x);
						line.setAttribute('y1',onEdges.p1.y);
						line.setAttribute('x2',onEdges.p2.x);
						line.setAttribute('y2',onEdges.p2.y);
						return [line];
					}
				};
			});
			this.extend('point',function(_specs){
				
				draw = this.override(draw, function(ctx){
					this(ctx);
					var sp = logic.getSpecs();
					ctx.fillStyle = ctx.strokeStyle;
					ctx.strokeStyle = 'transparent';
					ctx.beginPath();
					ctx.arc(sp.location.x, sp.location.y, 2*thickness, 0, 2*Math.PI);
					ctx.closePath();
					ctx.fill();
				});

				name = specs.name || 'point';
				getNewShapeLogic = function(sp){return shapeLogic.point(sp);}
				logic = getNewShapeLogic(_specs);

				toSvg = function(){
					var circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
					circle.setAttribute('stroke','transparent');
					circle.setAttribute('fill', stroke);
					var sp = logic.getSpecs();
					circle.setAttribute('cx', sp.location.x);
					circle.setAttribute('cy', sp.location.y);
					circle.setAttribute('r', 2*thickness);
					return [circle];
				};
				
			});
			this.extend('locus', function(_specs){
				draw = this.override(draw, function(ctx){
					this(ctx);
					var ps = logic.getSpecs().pointSets;
					ps.map(function(s){
						ctx.beginPath();
						s.map(function(p, i){
							if(i==0){
								ctx.moveTo(p.x, p.y);
							}else{
								ctx.lineTo(p.x, p.y);
							}
						});
						ctx.stroke();
					});
				});
				name = specs.name || 'point';
				getNewShapeLogic = function(sp){return shapeLogic.locus(sp);}
				logic = getNewShapeLogic(_specs);
				toSvg = function(){
					var ps = logic.getSpecs().pointSets;
					return ps.map(function(s){
						var path = document.createElementNS('http://www.w3.org/2000/svg','path');
						setSvgAttributes(path);
						var d="";
						for(var i=0;i<s.length;i++){
							if(i==0){
								d += "M "+s[i].x+" "+s[i].y;
							}else{
								d += " L "+s[i].x+" "+s[i].y;
							}
						}
						path.setAttribute('d',d);
						return path;
					});
				};
			});
		});

		var intersections = intersectionSet();

		var shapes = [];

		var wrapperSet = copySet([], function(s){
			var wrapper, onremove = sender();
			onremove.add(function(){
				log.removeCallsWithArgument(wrapper);
			});
			wrapper = {
				remove: function(){
					var index = shapes.indexOf(s);
					if(index != -1){
						shapes.splice(index, 1);
						intersections.removeForShape(s);
						wrapperSet.removeFor(s);
						onremove();
						draw();
					}
				},
				makeAvailable: function(b){s.makeAvailable(b)},
				onmouseover:function(f){s.onmouseover.add(f);},
				onmouseout: function(f){s.onmouseout.add(f);},
				onclick: function(f){s.onclick.add(f);},
				onchange: function(f){s.onchange(f);},
				onchangeavailability: function(f){s.onchangeavailability(f);},
				ondrag: function(f){s.ondrag.add(f);},
				onremove: function(f){onremove.add(f);},
				dragTo: function(p){s.dragTo(p);},
				getChanger: s.getChanger,
				getSpecs: s.getSpecs,
				exclude: function(b){s.toBeExcludedFromMouseEvents = b;},
				closestPointTo: s.closestPointTo,
				repositionPoint: s.repositionPoint,
				hideUnhide:s.hideUnhide,
				getNewShapeLogic: s.getNewShapeLogic,
				toString:s.toString,
				passesFilter:s.passesFilter,
				movePointAround: s.movePointAround,
				setLabel:s.setLabel,
				getLabelLocation:s.getLabelLocation,
				toConstructionString:s.toConstructionString
			};
			return wrapper;
		});

		var intersectionWrapperSet = copySet([], function(i){
			return {
				s1: wrapperBelongingTo(i.s1),
				s2: wrapperBelongingTo(i.s2),
				calculate: i.calculate,
				toConstructionString:function(getShapeName){
					var currentLoc = i.calculate();
					return 'intersection('+getShapeName(this.s1)+','+getShapeName(this.s2)+','+(currentLoc ? currentLoc.toString() : i.id.toString())+')';
				}
			};
		});

		var wrapperBelongingTo = function(s){
			return wrapperSet.copyOf(s);
		};

		var shapeBelongingTo = function(w){
			return wrapperSet.originalOf(w);
		};

		var getIntersectionForShapesAndPoint = function(w1, w2, p){
			return intersectionWrapperSet.addFor(intersections.getForShapes(shapeBelongingTo(w1), shapeBelongingTo(w2), p));
		};

		var getIntersectionForShapesAndId = function(w1, w2, id){
			return intersectionWrapperSet.addFor(intersections.getForShapesAndId(shapeBelongingTo(w1), shapeBelongingTo(w2), id));
		};

		var draw = throttle(function(){
			c.width = w;
			shapes.map(function(s){
				s.draw(context);
			});
			ondraw();
		}, 5);

		var onmouseovershape = function(s, e){};

		var onclickshape = function(s, e){};

		var onmousedownonshape = function(s, e){};

		var onmouseovernotshape = function(e){};

		var onmouseoverintersection = function(s1, s2, e){};

		var onclickintersection = function(i, e){};

		var onmouseup = function(e){};

		var onclicknotshape = function(e){};

		var addShape = function(s, toBeExcludedFromMouseEvents){
			shapes.map(function(ss){
				intersections.makeForShapes([s, ss]);
			});
			//s.setName('shape'+(shapes.length));
			s.toBeExcludedFromMouseEvents = toBeExcludedFromMouseEvents || false;
			shapes.push(s);
			shapes.sort((function(){
				var pointness = function(s){return s.passesFilter(shapeFilter.POINT)?1:0;};
				return function(a,b){return pointness(a) - pointness(b);};
			})());
			var wrapper = wrapperSet.addFor(s);
			draw();
			return wrapper;
		};

		var toSvg = function(){
			var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
			svg.setAttribute('width',w);
			svg.setAttribute('height', h);
			svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
			shapes.map(function(s){
				if(s.isAvailable() && !s.isHidden()){
					var els = s.toSvg();
					if(els && els.length){
						els.map(function(el){
							svg.appendChild(el);
						});
					}
				}
			});
			return svg;
		};

		var selection = (function(){
			var all = [];
			var addShape = function(w){
				var s = shapeBelongingTo(w);
				s.setSelected(true);
				all.push(s);
			};
			var clear = function(){
				all.map(function(s){s.setSelected(false);});
				all = [];
			};
			var removeAll = function(){
				all.map(function(s){wrapperBelongingTo(s).remove();});
				clear();
			};
			return {
				addShape: addShape,
				clear: clear,
				removeAll:removeAll
			};
		})();

		var mouseActionHandler = function(doToHitShape, doToNotHitShape, doIfNotHitShape, doToHitIntersection, drawAfter){
			doToHitShape = doToHitShape || function(){};
			doToNotHitShape = doToNotHitShape || function(){};
			doIfNotHitShape = doIfNotHitShape || function(){};
			doToHitIntersection = doToHitIntersection || function(){};
			var toReturn = function(e){
				var hitPoints, hitShape, hitIntersection, intersectingShape1, intersectingShape2, hitShapes = [];
				shapes.map(function(s){
					if(!s.toBeExcludedFromMouseEvents && s.isAvailable() && (!s.isHidden() || showHidden) && s.passesFilter(currentMouseFilter) && s.contains(point(e.clientX, e.clientY))){
						hitShapes.push(s);
						
					}else{
						doToNotHitShape(s, e);
					}
				});
				if(hitShapes.length == 0){
					doIfNotHitShape(e);
				}else{
					hitPoints = hitShapes.filter(function(s){return s.passesFilter(shapeFilter.POINT);});
					if(hitPoints.length > 0){
						doToHitShape(hitPoints[hitPoints.length - 1], e);
					}else{
						if(hitShapes.length == 1){
							doToHitShape(hitShapes[hitShapes.length - 1], e);
						}else{
							hitIntersection = intersections.getForShapes(hitShapes[hitShapes.length - 2], hitShapes[hitShapes.length - 1], point(e.clientX, e.clientY));
							if(hitIntersection){
								doToHitIntersection((function(i){
									return intersectionWrapperSet.addFor(i);
								})(hitIntersection), e);
							}else{
								doToHitShape(hitShapes[hitShapes.length - 1], e);
							}
							
						}
					}
					
				}
				if(drawAfter){
					draw();
				}
				
			};
			return toReturn;
		};

		var cursorSetter = {
			abouttograb: function(){c.style.cursor = "-webkit-grab";},
			grabbing:function(){c.style.cursor = "-webkit-grabbing";},
			none: function(){c.style.cursor = "default";},
			pointer: function(){c.style.cursor = 'pointer';}
		};

		var shapeCursor = cursorSetter.none;
		var noShapeCursor = cursorSetter.none;

		var moveHandler = mouseActionHandler(
			function(s, e){
				shapeCursor();
				s.onmouseover(e);
				onmouseovershape(wrapperBelongingTo(s), e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				noShapeCursor();
				onmouseovernotshape(e);
			},
			function(i, e){
				onmouseoverintersection(i, e);
			},
			true
		);

		var downHandler = mouseActionHandler(
			function(s, e){
				onmousedownonshape(wrapperBelongingTo(s), e);
			}
		);

		var clickHandler = mouseActionHandler(
			function(s, e){
				s.onclick(e);
				onclickshape(wrapperBelongingTo(s), e);
			},
			function(s, e){
				s.onmouseout(e);
			},
			function(e){
				onclicknotshape(e);
			},
			function(i, e){
				onclickintersection(i, e);
			}
			
		);

		c.addEventListener('mousemove', moveHandler);

		c.addEventListener('mousedown', downHandler);

		c.addEventListener('mouseup', function(e){
			onmouseup(e);
			draw();
		});

		c.addEventListener('click', clickHandler);

		return {
			addCircle: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.circle({stroke:'#d66'}, specs), toBeExcludedFromMouseEvents);
			},
			addPoint: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.point({stroke:'#66d'}, specs), toBeExcludedFromMouseEvents);
			},
			addLine: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.line({stroke:'#6d6'}, specs), toBeExcludedFromMouseEvents);
			},
			addLocus: function(specs, toBeExcludedFromMouseEvents){
				return addShape(shape.locus({stroke:'#dd6'}, specs), toBeExcludedFromMouseEvents);
			},
			onmouseovershape: function(f){onmouseovershape = f || function(){};},
			onmousedownonshape: function(f){onmousedownonshape = f || function(){};},
			onmouseovernotshape: function(f){
				onmouseovernotshape = f || function(){};
			},
			ondraw:function(f){ondraw.add(f);},
			getIntersectionForShapesAndPoint:getIntersectionForShapesAndPoint,
			getIntersectionForShapesAndId:getIntersectionForShapesAndId,
			onmouseoverintersection: function(f){onmouseoverintersection = f || function(){};},
			onclickintersection: function(f){onclickintersection = f || function(){};},
			onclickshape: function(f){onclickshape = f || function(){};},
			onclicknotshape: function(f){onclicknotshape = f || function(){};},
			onmouseup: function(f){onmouseup = f || function(){};},
			setMouseFilter: function(f){currentMouseFilter = f;},
			mouseFilter: shapeFilter,
			selectShape: function(s){selection.addShape(s);},
			clearSelection: function(){selection.clear();},
			removeSelection: function(){selection.removeAll();},
			showHidden:function(){showHidden = true;},
			hideHidden: function(){showHidden = false;},
			setShapeCursor: function(c){shapeCursor = c;},
			setNoShapeCursor: function(c){noShapeCursor = c;},
			cursor: cursorSetter,
			toSvg:toSvg

		};

	})(w,h);


	var log = (function(){
		var floatPattern = "-?\\d+(?:\\.\\d+)?(?:e-?\\d+)?";
		var allCalls = [];
		var call = function(f, name, args){
			var toString = function(getShapeName){
				return name+'('+args.map(getShapeName).join(',')+')';
			};
			return {
				f:f,
				name:name,
				args:args,
				apply:function(){
					f.apply(null, args);
				},
				toString:toString
			};
		};
		var addCall = function(f, name, args){
			allCalls.push(call(f, name, args));
		};
		var registeredMaker;
		var register = function(maker){
			registeredMaker = maker;
			for(var m in maker){
				if(maker.hasOwnProperty(m)){
					maker[m] = (function(orig, m){
						return function(){
							addCall(orig, m, Array.prototype.slice.apply(arguments));
							orig.apply(maker, arguments);
						};
					})(maker[m], m);
				}
			}
		};
		
		var toString = function(){
			var allShapes = distinctArray([]);
			allCalls.map(function(c){
				c.args.map(function(a){allShapes.push(a);});
			});
			var shapeNames = copySet(allShapes.arr, function(s, i){return i.toString();});
			return allCalls
				.map(function(c){
					return c.toString(shapeNames.copyOf);
				}).join('')+
				';['+
				allShapes.arr.map(function(s){
					return s.toConstructionString(shapeNames.copyOf);
				}).join(';')+";"+
				']';
		};
		var argumentMakers = [
			{
				level:0,
				matches:function(kind){return kind == "point";},
				make:function(info){
					return function(){
						var match = info.match(new RegExp("("+floatPattern+"),("+floatPattern+")"));
						var p = point(parseFloat(match[1]), parseFloat(match[2]));
						return canvas.addPoint({location:p});
					};
				}
			},{
				level:0,
				matches:function(kind){return kind == "circle";},
				make:function(info){
					return function(){
						var match = info.match(new RegExp("\\(("+floatPattern+"),("+floatPattern+")\\),("+floatPattern+")"));
						return canvas.addCircle({center:point(parseFloat(match[1]), parseFloat(match[2])),r:parseFloat(match[3])});
					};
				}
			},{
				level:0,
				matches:function(kind){return kind == "line";},
				make:function(info){
					return function(){
						var match = info.match(new RegExp("\\(("+floatPattern+"),("+floatPattern+")\\),\\(("+floatPattern+"),("+floatPattern+")\\)"));
						return canvas.addLine({p1:point(parseFloat(match[1]),parseFloat(match[2])),p2:point(parseFloat(match[3]),parseFloat(match[4]))});
					};
				}
			},{
				level:1,
				matches:function(kind){return kind == "intersection";},
				make:function(info){
					return function(argByIndex){
						var matchWithId, matchWithPoint = info.match(new RegExp("(\\d+),(\\d+),\\(("+floatPattern+"),("+floatPattern+")\\)"));
						if(matchWithPoint){
							return canvas.getIntersectionForShapesAndPoint(argByIndex(matchWithPoint[1]), argByIndex(matchWithPoint[2]), point(parseFloat(matchWithPoint[3]), parseFloat(matchWithPoint[4])));
						}
						else{
							matchWithId = info.match(new RegExp("(\\d+),(\\d+),(\\d+)"));
							return canvas.getIntersectionForShapesAndId(argByIndex(matchWithId[1]), argByIndex(matchWithId[2]), parseInt(matchWithId[3]));
						}
					};
				}
			},{
				level:0,
				matches:function(kind){return kind == "locus";},
				make:function(info){
					return function(){
						return canvas.addLocus({});
					};
				}
			}
		];
		
		var backFromString = function(s){
			var match = s.match(/^((?:\w+\([^)]+\))+);\[([^\]]+)\]$/);
			if(match){
				var commands = match[1].match(/\w+\([^)]+\)/g);
				var argsStrings = match[2].match(/.*?;/g);
				var makers = argsStrings.map(function(s){
					var match = s.match(/(\w+)\((.*)\);/);
					var maker = argumentMakers.filter(function(m){return m.matches(match[1])})[0];
					return {level:maker.level,make:maker.make(match[2])};
				});
				var argsArr = Array.apply(null, new Array(argsStrings.length));
				var argByIndex = function(i){return argsArr[i];};
				var levels = distinctArray(makers.map(function(m){return m.level;})).arr.sort(function(a,b){return a-b;});
				levels.map(function(l){
					makers.filter(function(m){return m.level == l}).map(function(m){
						argsArr[makers.indexOf(m)] = m.make(argByIndex);
					});
				});
				commands.map(function(c){
					var match = c.match(/(\w+)\(([^)]+)\)/);
					var methodName = match[1];
					var args = match[2].match(/\d+/g).map(function(i){return argsArr[parseInt(i)];});
					registeredMaker[methodName].apply(null, args);
				});
			}
		};
		var removeCallsWithArgument = function(a){
			allCalls = allCalls.filter(function(c){
				return !c.args.some(function(aa){return aa == a;});
			});
		};
		return {
			addCall: addCall,
			register:register,
			toString:toString,
			backFromString:backFromString,
			removeCallsWithArgument:removeCallsWithArgument
		};
	})();

	

	var structure = (function(){
		var linkExistence;
		var allLinks = [];
		
		
		var intersectionLinks = [];
		var getLinksForDependentShape = function(s){
			return allLinks.filter(function(l){return l.dependent == s;});
		};
		var isDependentShape = function(s){
			return getLinksForDependentShape(s).length > 0 || getIntersectionLinksForDependentShape(s).length > 0;
		};
		var isMovableShape = function(s){
			return !isDependentShape(s) || (getIntersectionLinksForDependentShape(s).length == 0 && !getLinksForDependentShape(s).some(function(l){return l.freedom == 0;}));
		};
		var getIntersectionLinksForDependentShape = function(s){
			return intersectionLinks.filter(function(l){return l.p == s;});
		};
		var getAllLinkedShapes = function(dependent, soFar){
			soFar = soFar || distinctArray([dependent]);
			getLinksForDependentShape(dependent).map(function(l){
				soFar.push(l.independent);
				getAllLinkedShapes(l.independent, soFar);
			});
			getIntersectionLinksForDependentShape(dependent).map(function(l){
				soFar.push(l.s1);
				soFar.push(l.s2);
				getAllLinkedShapes(l.s1, soFar);
				getAllLinkedShapes(l.s2, soFar);
			});
			return soFar.arr;
		};
		var getAllLinksForShape = function(dependent, soFar){
			soFar = soFar || distinctArray([]);
			getLinksForDependentShape(dependent).map(function(l){
				soFar.push(l);
				getAllLinksForShape(l.independent, soFar);
			});
			getIntersectionLinksForDependentShape(dependent).map(function(l){
				soFar.push(l);
				getAllLinksForShape(l.s1, soFar);
				getAllLinksForShape(l.s2, soFar);
			});
			return soFar.arr;
		};
		
		var changeLink = function(dependent, independent, howToChange, constants, freedom){
			var apply = function(){
				independent.onchange(function(oldSpecs, newSpecs){
					howToChange(oldSpecs, newSpecs, dependent.getChanger(), constants ? constants.map(function(s){return s.getSpecs();}) : [], dependent, independent);
				});
				linkExistence(dependent, [independent]);
			};
			var clone = function(getCopyFor, getIntersectionForShapes){
				return changeLink(getCopyFor(dependent), getCopyFor(independent), howToChange, constants ? constants.map(getCopyFor): [], freedom);
			};
			return {
				dependent: dependent,
				independent: independent,
				howToChange: howToChange,
				constants: constants,
				freedom:freedom,
				apply:apply,
				clone:clone
			};
		};
		var intersectionLink = function(pointShape, s1, s2, i){
			var apply = function(){
				var setLocation = function(){
					var loc = i.calculate();
					if(loc){
						pointShape.makeAvailable(true);
						pointShape.getChanger().setLocation(loc);
					}else{
						pointShape.makeAvailable(false);
					}
				};
				linkExistence(pointShape, [i.s1, i.s2]);
				i.s1.onchange(setLocation);
				i.s2.onchange(setLocation);
				setLocation();
			};
			var clone = function(getCopyFor, getIntersectionForShapes){
				return intersectionLink(
					getCopyFor(pointShape),
					getCopyFor(s1),
					getCopyFor(s2),
					getIntersectionForShapes(
						getCopyFor(s1),
						getCopyFor(s2),
						getCopyFor(pointShape).getSpecs().location
						)
					);
			};
			return {
				s1:s1,
				s2:s2,
				p: pointShape,
				apply: apply,
				clone: clone
			};
		};

		var movePointAround = function(pointShape){
			var independent = getLinksForDependentShape(pointShape)[0].independent;
			return independent.movePointAround(pointShape.getSpecs().location);
		};
		linkExistence = function(s, ss){
			ss.map(function(s_){
				if(s_.onremove){
					s_.onremove(function(){s.remove();});
				}
				s_.onchangeavailability(function(b){s.makeAvailable(b);});
			});
		};
		var linkChange = function(dependent, independent, howToChange, constants, freedom){
			freedom = freedom || 0;
			var link = changeLink(dependent, independent, howToChange, constants, freedom);
			allLinks.push(link);
			link.apply();
		};
		var linkToIntersection = function(dependentPoint, s1, s2, i){
			var link = intersectionLink(dependentPoint, s1, s2, i);
			intersectionLinks.push(link);
			link.apply();
		};
		var maker = {
			point: function(canvasPoint, canvasShape){
				var putOnShapeClosestTo;
				if(!canvasShape){
					canvasPoint.ondrag(function(p){
						canvasPoint.getChanger().setLocation(p);
					});
				}else{
					putOnShapeClosestTo = function(p){
						canvasPoint.getChanger().setLocation(canvasShape.closestPointTo(p));
					};
					canvasPoint.ondrag(putOnShapeClosestTo);
					putOnShapeClosestTo(canvasPoint.getSpecs().location);
					linkChange(canvasPoint, canvasShape, function(oldSpecs, newSpecs, changer, constants, dependent, independent){
						changer.setLocation(independent.repositionPoint(dependent.getSpecs().location, oldSpecs, newSpecs));
					}, null, 1);
				}
				
				return {
					onchange: function(f){canvasPoint.onchange(f);}
				};
			},
			pointOnIntersection: function(canvasPoint, i){
				
				linkToIntersection(canvasPoint, i.s1, i.s2, i);
			},
			circle: function(canvasPointCenter, canvasCircle, canvasPointBoundary){
				if(!canvasPointBoundary){
					linkChange(canvasCircle, canvasPointCenter, function(oldSpecs, newSpecs, changer){
						changer.setCenter(newSpecs.location);
					}, null, 1);
					canvasCircle.ondrag(function(p){
						var center = canvasCircle.getSpecs().center;
						var changer = canvasCircle.getChanger();
						changer.setR(center.minus(p).mod());
					});
				}else{
					
					linkChange(
						canvasCircle,
						canvasPointBoundary,
						function(oldSpecs, newSpecs, changer, constants){
							changer.setR(newSpecs.location.minus(constants[0].location).mod());
						},
						[canvasPointCenter], 0);
					linkChange(
						canvasCircle,
						canvasPointCenter,
						function(oldSpecs, newSpecs, changer, constants){
							changer.setCenter(newSpecs.location);
							changer.setR(newSpecs.location.minus(constants[0].location).mod());
						},
						[canvasPointBoundary], 0);
				}
			},
			line: function(canvasPoint1, canvasLine, canvasPoint2){
				if(!canvasPoint2){
					canvasLine.ondrag(function(p){
						canvasLine.getChanger().moveTo(p);
					});

					linkChange(canvasLine, canvasPoint1, function(oldSpecs, newSpecs, changer){
						var diff = newSpecs.location.minus(oldSpecs.location);
						changer.translateBy(diff);
					}, null, 1);
				}else{
					var changer = canvasLine.getChanger();
					changer.setP1(canvasPoint1.getSpecs().location);
					changer.setP2(canvasPoint2.getSpecs().location);
					
					

					linkChange(canvasLine, canvasPoint2, function(oldSpecs, newSpecs, changer){
						changer.setP2(newSpecs.location);
					}, null, 0);

					linkChange(canvasLine, canvasPoint1, function(oldSpecs, newSpecs, changer){
						changer.setP1(newSpecs.location);
					}, null, 0);
				}
			},
			perpendicularLine: function(canvasPoint, canvasPerpendicularLine, canvasLine){
				linkChange(canvasPerpendicularLine, canvasPoint, function(oldSpecs, newSpecs, changer){
					changer.translateBy(newSpecs.location.minus(oldSpecs.location));
				}, null, 0);

				linkChange(canvasPerpendicularLine, canvasLine, function(oldSpecs, newSpecs, changer){
					changer.setFromP1(newSpecs.p2.minus(newSpecs.p1).matrix(0, -1, 1, 0));
				}, null, 0);
			},
			perpendicularBisector: function(canvasPoint1, perpBis, canvasPoint2){
				linkChange(perpBis, canvasPoint1, function(oldSpecs, newSpecs, changer, constants){
					changer.setP1(newSpecs.location.plus(constants[0].location).scale(1/2));
					changer.setFromP1(constants[0].location.minus(newSpecs.location).matrix(0, -1, 1, 0));
				}, [canvasPoint2], 0);

				linkChange(perpBis, canvasPoint2, function(oldSpecs, newSpecs, changer, constants){
					changer.setP1(constants[0].location.plus(newSpecs.location).scale(1/2));
					changer.setFromP1(newSpecs.location.minus(constants[0].location).matrix(0, -1, 1, 0));
				}, [canvasPoint1], 0);
			},
			pointLineReflection: function(canvasPoint, line, canvasPointReflection){
				linkChange(canvasPointReflection, line, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(reflectPointInLine(newSpecs.p1, newSpecs.p2, constants[0].location));
				}, [canvasPoint], 0);

				linkChange(canvasPointReflection, canvasPoint, function(oldSpecs, newSpecs, changer, constants){
					changer.setLocation(reflectPointInLine(constants[0].p1, constants[0].p2, newSpecs.location));
				}, [line], 0);
			},
			locus: function(canvasPoint1, locusShape, canvasPoint2){
				var allShapesInvolved = getAllLinkedShapes(canvasPoint1);
				var shapesToWatch = allShapesInvolved.filter(function(s){return isMovableShape(s);});

				if(shapesToWatch.some(function(s){return s == canvasPoint2;}) && isDependentShape(canvasPoint2)){
					console.log("ok");
					var allLinks = getAllLinksForShape(canvasPoint1);
					var intersections = intersectionSet();
					var copies = copySet(allShapesInvolved, function(s){return s.getNewShapeLogic();});
					intersections.makeForShapes(copies.allCopies());
					allLinks.map(function(l){
						l.clone(copies.copyOf, intersections.getForShapes).apply();
					});
					var p1Copy = copies.copyOf(canvasPoint1), p2Copy = copies.copyOf(canvasPoint2);
					var setAllCopies = (function(){
						var result = sender();
						allShapesInvolved.map(function(o){
							var c = copies.copyOf(o);
							result.add(function(){
								c.getChanger().useSpecs(o.getSpecs());
							});
						});
						return result;
					})();
					
					var createPoints = throttle(function(){
						console.log("create points");
						var originalPoints = movePointAround(canvasPoint2), pointSets = [], newPoints = [];
						pointSets.push(newPoints);
						originalPoints.map(function(p){
							p2Copy.getChanger().setLocation(p);
							if(p1Copy.isAvailable()){
								newPoints.push(p1Copy.getSpecs().location);
							}else{
								newPoints = [];
								pointSets.push(newPoints);
							}
							
						});
						locusShape.getChanger().setPointSets(pointSets);
						
					}, 2);
					canvasPoint1.onchange(function(oldSpecs, newSpecs){
						setAllCopies();
						createPoints();
					});
					canvasPoint1.onremove(function(){
						locusShape.remove();
					});
					locusShape.onremove(function(){createPoints = function(){};});
					createPoints();
				}else{
					console.log("not ok");
				}
			}
		};
		log.register(maker);
		return maker;
	})();

	var action = (function(){
		var selectLocationOrPoint = function(send, suggest){
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.onmouseovernotshape(function(e){
				suggest(point(e.clientX, e.clientY));
			});
			canvas.onmouseovershape(function(s, e){
				suggest(s.closestPointTo(point(e.clientX, e.clientY)));
			});
			canvas.onclicknotshape(function(e){
				send(point(e.clientX, e.clientY));
			});
			canvas.onclickshape(function(s,e){
				send(s.closestPointTo(point(e.clientX, e.clientY)), s);
			});
		};
		var selectLocationOrShapeOrIntersection = function(send, suggest){
			canvas.setMouseFilter(canvas.mouseFilter.ALL);
			canvas.setShapeCursor(canvas.cursor.none);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovernotshape(function(e){
				suggest(point(e.clientX, e.clientY));
			});
			canvas.onmouseovershape(function(s,e){
				suggest(s.closestPointTo(point(e.clientX, e.clientY)));
			});
			canvas.onmouseoverintersection(function(i, e){
				suggest(i.calculate());
			});
			canvas.onclicknotshape(function(e){
				send(point(e.clientX, e.clientY));
			});
			canvas.onclickshape(function(s, e){
				send(s.closestPointTo(point(e.clientX, e.clientY)), s);
			});
			canvas.onclickintersection(function(i){
				send(null, null, i);
			});
		};
		var selectPoint = function(send){
			canvas.setMouseFilter(canvas.mouseFilter.POINT);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovershape();
			canvas.onmouseovernotshape();
			canvas.onclickshape(function(s, e){
				send(s);
			});
		};
		var selectLine = function(send){
			canvas.setMouseFilter(canvas.mouseFilter.LINE);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovershape();
			canvas.onmouseovernotshape();
			canvas.onclickshape(function(s, e){
				send(s);
			});
		};
		var selectShape = function(send){
			canvas.setMouseFilter(canvas.mouseFilter.ALL);
			canvas.setShapeCursor(canvas.cursor.pointer);
			canvas.setNoShapeCursor(canvas.cursor.none);
			canvas.onmousedownonshape();
			canvas.onmouseovershape();
			canvas.onmouseovernotshape();
			canvas.onclickshape(function(s, e){
				send(s);
			});

		};
		return {
			doNothing: function(){
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.setShapeCursor(canvas.cursor.abouttograb);
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.onclickshape();
				canvas.onclicknotshape();
				canvas.onmousedownonshape(action.startMoving);
				canvas.onmouseovershape();
				canvas.onmouseoverintersection();
				canvas.onclickintersection();
				canvas.onmouseovernotshape();
				canvas.onmouseup();
			},
			select: function(stop){
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.onmousedownonshape();
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.setShapeCursor(canvas.cursor.none);
				canvas.onclickshape(function(s, e){
					canvas.selectShape(s);
				});
				canvas.onclicknotshape(function(e){
					canvas.clearSelection();
				});
				return function(){
					canvas.clearSelection();
					stop();
				};
			},
			hideUnhide: function(stop){
				canvas.showHidden();
				canvas.setMouseFilter(canvas.mouseFilter.ALL);
				canvas.onmousedownonshape();
				canvas.setNoShapeCursor(canvas.cursor.none);
				canvas.setShapeCursor(canvas.cursor.none);
				canvas.onclicknotshape();
				canvas.onclickshape(function(s, e){
					s.hideUnhide();
				});
				return function(){
					canvas.hideHidden();
					stop();
				};
			},
			startMoving: function(s, e){
				canvas.setShapeCursor(canvas.cursor.grabbing);
				canvas.setNoShapeCursor(canvas.cursor.grabbing);
				var doMove = function(e){
					s.dragTo(point(e.clientX, e.clientY));
				};

				canvas.onmouseup(action.doNothing);
				canvas.onmouseovershape(function(s, e){doMove(e);});
				canvas.onmouseovernotshape(doMove);
				canvas.onmouseoverintersection(function(i,e){doMove(e);});
				doMove(e);
			},
			makePointStructure: function(res, stop){
				var p = canvas.addPoint({
					location: point(200,200)
				}, true);
				
				selectLocationOrShapeOrIntersection(function(l, s, i){
					if(i){
						res(structure.pointOnIntersection(p, i));
					}else{
						if(s){
							res(structure.point(p, s));
						}else{
							res(structure.point(p));
						}
					}
					p.exclude(false);
					stop();
				},function(l){
					p.getChanger().setLocation(l);
				});
				
				return function(){
					p.remove();
					stop();
				};
			},
			makeCircleStructure: function(res, stop){
				var revert = stop;
				var chosenCenter, growCircle, circle;
				selectPoint(function(s){
					chosenCenter = s;
					circle = canvas.addCircle({center:chosenCenter.getSpecs().location,r:20});
					growCircle = function(p){circle.getChanger().setR(p.minus(chosenCenter.getSpecs().location).mod());};
					selectLocationOrPoint(function(l, p){
						if(p){
							res(structure.circle(chosenCenter, circle, p));
							stop();
						}else{
							res(structure.circle(chosenCenter, circle));
							stop();
						}
					},function(l){
						growCircle(l);
					});
					
					revert = function(){
						circle.remove();
						stop();
					};
				});
				return function(){
					revert();
				};
			},
			makeLineStructure: function(res, stop){
				var revert = stop;
				var chosenP1, moveLine, line;
				selectPoint(function(s){
					chosenP1 = s;
					line = canvas.addLine({p1:chosenP1.getSpecs().location, p2:chosenP1.getSpecs().location.plus(point(100,0))});
					moveLine = function(p){line.getChanger().moveTo(p);};
					selectLocationOrPoint(function(l, p){
						if(p){
							res(structure.line(chosenP1, line, p));
							stop();
						}else{
							res(structure.line(chosenP1, line));
							stop();
						}
					},function(l){
						moveLine(l);
					});
					
					revert = function(){
						line.remove();
						stop();
					};
				});
				return function(){
					revert();
				};
			},
			makePerpendicularLine: function(res, stop){
				var chosenPoint, revert = stop;
				selectPoint(function(s){
					chosenPoint = s;
					selectLine(function(l){
						var lSpecs = l.getSpecs(), p1 = chosenPoint.getSpecs().location, p2 = p1.plus(lSpecs.p2.minus(lSpecs.p1).matrix(0,-1,1,0));
						var perpLine = canvas.addLine({p1:p1, p2:p2});
						res(structure.perpendicularLine(chosenPoint, perpLine, l));
						stop();
					});
				});
				return function(){
					revert();
				};
			},
			makePerpendicularBisector: function(res, stop){
				var p1, revert = stop;
				selectPoint(function(p1){
					selectPoint(function(p2){
						var p1loc = p1.getSpecs().location, p2loc = p2.getSpecs().location, newp1loc = p1loc.plus(p2loc).scale(1/2);
						var perpBis = canvas.addLine({
							p1: newp1loc,
							p2: newp1loc.plus(p2loc.minus(p1loc).matrix(0, -1, 1, 0))
						});
						res(structure.perpendicularBisector(p1, perpBis, p2));
						stop();
					});
				});
				return function(){
					revert();
				};
			},
			makeLocus: function(res, stop){
				
				selectPoint(function(point1){
					selectPoint(function(point2){
						res(structure.locus(point1, canvas.addLocus({}), point2));
						stop();
					});
				});
				return stop;
			},
			makePointLineReflection: function(res, stop){
				selectPoint(function(p){
					selectLine(function(l){
						var lSpecs = l.getSpecs();
						var refl = canvas.addPoint({location: reflectPointInLine(lSpecs.p1, lSpecs.p2, p.getSpecs().location)});
						res(structure.pointLineReflection(p, l, refl));
						stop();
					});
				});
				return stop;
			},
			setLabel:function(res, stop){
				var revert = stop;
				selectShape(function(s){
					var labelloc = s.getLabelLocation();
					makeNode("<input type='text' style='width:30px;position:absolute;left:"+(labelloc.x + 5)+"px;top:"+(labelloc.y - 15)+"px' id='1'>", function(input){
						var remove = function(){
							document.body.removeChild(input);
						};
						document.body.appendChild(input);
						input.focus();
						input.addEventListener('blur',function(){
							s.setLabel(input.value);
							remove();
							res();
							stop();
						});
						
						revert = function(){
							remove();
							stop();
						};
					});
				});
				return function(){
					revert();
				};
			}
		};
	})();

	var hash = (function(){
		var read = function(){
			log.backFromString(decodeURI(window.location.hash.substr(1)));
		};
		var write = throttle(function(){
			window.location.hash = encodeURI(log.toString());
		}, 500);
		canvas.ondraw(write);
		read();
		return {write:write};
	})();

	var button = (function(){
		var positionProvider = function(){
			var x = 20, y = 20;
			return {
				next:function(){
					var p = {x:x,y:y};
					x += 40;
					return p;
				}
			};
		};
		var leftPosition = positionProvider(), rightPosition = positionProvider();
		var addClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class') + " "+name);
		};
		var removeClass = function(el, name){
			el.setAttribute('class', el.getAttribute('class').split(/[\s]+/g).filter(function(c){return c!=name;}).join(' '));
		};
		var button = function(a, className, right){
			var p = (right ? rightPosition : leftPosition).next();
			var b = makeNode("<div id='1' class='button"+(className?" "+className:"")+"' style='"+(right ? "right:"+p.x+"px" : "left:"+p.x+"px")+";top:"+p.y+"px'></div>", function(div){
				var makeActive = function(){addClass(div, 'active');};
				var makeNonActive = function(){removeClass(div, 'active');};
				var normalOnClick = function(e){
					var stop;
					e.preventDefault();
					makeActive();
					stop = a(function(){
						makeNonActive();
						div.onclick = normalOnClick;
					});
					if(stop){
						div.onclick = function(){
							stop();
							makeNonActive();
							div.onclick = normalOnClick;
						};
					}
					
				};
				div.onclick = normalOnClick;
				document.body.appendChild(div);
			});
		};
		return button;
	})();

	button(function(deactivateButton){
		return action.makePointStructure(function(p){
			
		}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "point");

	button(function(deactivateButton){
		return action.makeCircleStructure(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "circle");

	button(function(deactivateButton){
		return action.makeLineStructure(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "line");

	button(function(deactivateButton){
		return action.makePerpendicularLine(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "perpendicular");

	button(function(deactivateButton){
		return action.makePerpendicularBisector(function(){}, function(){
			action.doNothing();
			deactivateButton();
		})
	},"bisect");

	button(function(deactivateButton){
		return action.makePointLineReflection(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "reflect-line");

	button(function(deactivateButton){
		return action.makeLocus(function(){},function(){
			action.doNothing();
			deactivateButton();
		});
	}, "locus");

	button(function(deactivateButton){
		return action.setLabel(function(){}, function(){
			action.doNothing();
			deactivateButton();
		});
	}, "label");

	button(function(deactivateButton){
		return action.select(function(){
			action.doNothing();
			deactivateButton();
		});
		
	}, "select", true);

	button(function(deactivateButton){
		return action.hideUnhide(function(){
			action.doNothing();
			deactivateButton();
		});
	},"hide", true);

	button(function(deactivateButton){
		canvas.removeSelection();
		deactivateButton();
	}, "remove", true);

	button(function(deactivateButton){
		makeNode('<div style="position:absolute;left:0px;top:0px;width:100%;height:100%;background-color:#fff" id="1"/>',function(div){
			div.appendChild(canvas.toSvg());
			document.body.innerHTML = '';
			document.body.appendChild(div);
		});
		deactivateButton();
	}, "svg", true);

	action.doNothing();

	

})(document, document.body.offsetWidth, document.body.offsetHeight);
</script>
</body>
</html>